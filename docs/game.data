Background = Class {
  init = function(self)
    self.image = love.graphics.newImage("asset/image/background.png");
    self.positions = {-SCREEN_HEIGHT, 0};
  end
};

function Background:update(dt)
  for i, p in ipairs(self.positions) do
    self.positions[i] = self.positions[i] + BACKGROUND_SPEED * dt;
    if self.positions[i] > SCREEN_HEIGHT then
      self.positions[i] = -SCREEN_HEIGHT;
    end
  end
end

function Background:draw()
  for i, p in ipairs(self.positions) do
    love.graphics.draw(self.image, 0, p);
  end
endplayerCollision = function(player, other)
  if not other.active then
    return nil;
  end

  if other.type == "bullet" or other.type == "bullet-pickup" then
    return "cross";
  end

  return nil;
end

pickupBoxCollision = function(pickupBox, other)
  if not other.active then
    return nil;
  end

  if other.type == "bullet-pickup" then
    return "cross";
  end

  return nil;
end

bulletCollision = function(bullet, other)
  if not other.active then
    return nil;
  end

  if other.type == "enemy" then
    return "cross";
  end

  return nil;
end

enemyCollision = function(enemy, other)
  if not other.active then
    return nil;
  end

  if other.type == "bullet-pickup" then
    return "cross";
  end

  return nil;
endfunction love.conf(t)
  t.identity = nil                    -- The name of the save directory (string)
  t.version = "0.10.2"                -- The L√ñVE version this game was made for (string)
  t.console = true                   -- Attach a console (boolean, Windows only)
  t.accelerometerjoystick = true      -- Enable the accelerometer on iOS and Android by exposing it as a Joystick (boolean)
  t.externalstorage = false           -- True to save files (and read from the save directory) in external storage on Android (boolean)
  t.gammacorrect = false              -- Enable gamma-correct rendering, when supported by the system (boolean)

  t.window.title = "Game Off 2017"         -- The window title (string)
  t.window.icon = nil                 -- Filepath to an image to use as the window's icon (string)
  t.window.width = 600                -- The window width (number)
  t.window.height = 800               -- The window height (number)
  t.window.borderless = false         -- Remove all border visuals from the window (boolean)
  t.window.resizable = false          -- Let the window be user-resizable (boolean)
  t.window.minwidth = 1               -- Minimum window width if the window is resizable (number)
  t.window.minheight = 1              -- Minimum window height if the window is resizable (number)
  t.window.fullscreen = false         -- Enable fullscreen (boolean)
  t.window.fullscreentype = "desktop" -- Choose between "desktop" fullscreen or "exclusive" fullscreen mode (string)
  t.window.vsync = true               -- Enable vertical sync (boolean)
  t.window.msaa = 0                   -- The number of samples to use with multi-sampled antialiasing (number)
  t.window.display = 1                -- Index of the monitor to show the window in (number)
  t.window.highdpi = false            -- Enable high-dpi mode for the window on a Retina display (boolean)
  t.window.x = nil                    -- The x-coordinate of the window's position in the specified display (number)
  t.window.y = nil                    -- The y-coordinate of the window's position in the specified display (number)

  t.modules.audio = true              -- Enable the audio module (boolean)
  t.modules.event = true              -- Enable the event module (boolean)
  t.modules.graphics = true           -- Enable the graphics module (boolean)
  t.modules.image = true              -- Enable the image module (boolean)
  t.modules.joystick = true           -- Enable the joystick module (boolean)
  t.modules.keyboard = true           -- Enable the keyboard module (boolean)
  t.modules.math = true               -- Enable the math module (boolean)
  t.modules.mouse = true              -- Enable the mouse module (boolean)
  t.modules.physics = true            -- Enable the physics module (boolean)
  t.modules.sound = true              -- Enable the sound module (boolean)
  t.modules.system = true             -- Enable the system module (boolean)
  t.modules.timer = true              -- Enable the timer module (boolean), Disabling it will result 0 delta time in love.update
  t.modules.touch = true              -- Enable the touch module (boolean)
  t.modules.video = true              -- Enable the video module (boolean)
  t.modules.window = true             -- Enable the window module (boolean)
  t.modules.thread = true             -- Enable the thread module (boolean)
endSCREEN_WIDTH = 600;
SCREEN_HEIGHT = 800;

KEY_LEFT = "left";
KEY_RIGHT = "right";
KEY_UP = "up";
KEY_DOWN = "down";
KEY_RUN = "lshift";
KEY_QUIT = "escape";

KEY_FIRE_STREAM = "z";
KEY_FIRE_SPREAD = "x";

BACKGROUND_SPEED = 100;

PLAYER_WIDTH = 32;
PLAYER_HEIGHT = 32;
PICKUP_BOX_WIDTH = PLAYER_WIDTH * 3;
PICKUP_BOX_HEIGHT = PLAYER_HEIGHT * 3;
PLAYER_SPEED = 300;
PLAYER_RUN_SPEED = 300;
PLAYER_MAX_HEALTH = 5;
PLAYER_INITIAL_DIMENSIONS = {
  x = 270,
  y = 700,
  w = PLAYER_WIDTH,
  h = PLAYER_HEIGHT
};

PICKUP_BOX_INITIAL_DIMENSIONS = {
  x = PLAYER_INITIAL_DIMENSIONS.x + PLAYER_WIDTH / 2 - PICKUP_BOX_WIDTH / 2,
  y = PLAYER_INITIAL_DIMENSIONS.y + PLAYER_HEIGHT / 2 - PICKUP_BOX_HEIGHT / 2,
  w = PICKUP_BOX_WIDTH,
  h = PICKUP_BOX_HEIGHT
};

MAX_HELD_BULLETS = 9;
BULLET_SIZE = 8;
BULLET_SPEED = 400;
BULLET_INITIAL_DIMENSIONS = {
  w = BULLET_SIZE * 2,
  h = BULLET_SIZE * 2
};

BULLET_SPREAD = {
  math.pi * 24/16,
  math.pi * 23/16,
  math.pi * 25/16,
  math.pi * 22/16,
  math.pi * 26/16,
  math.pi * 21/16,
  math.pi * 27/16,
  math.pi * 20/16,
  math.pi * 28/16
};

ENEMY_SIZE = 32;

STRAIGHT_ENEMY_FIRE_RATE = 0.4;
STRAIGHT_ENEMY_SPEED = 100;
STRAIGHT_ENEMY_INITIAL_DIMENSIONS = {
  w = ENEMY_SIZE,
  h = ENEMY_SIZE
};

SIDEWAYS_ENEMY_FIRE_RATE = 0.4;
SIDEWAYS_ENEMY_SPEED = 150;
SIDEWAYS_ENEMY_INITIAL_DIMENSIONS = {
  w = ENEMY_SIZE,
  h = ENEMY_SIZE
};

PENDULUM_ENEMY_SPEED = 100;
PENDULUM_ENEMY_LEFT_LIMIT = ENEMY_SIZE;
PENDULUM_ENEMY_RIGHT_LIMIT = SCREEN_WIDTH - ENEMY_SIZE * 2;
PENDULUM_ENEMY_MOVEMENT_RATE = 1.5;
PENDULUM_ENEMY_INITIAL_DIMENSIONS = {
  w = ENEMY_SIZE,
  h = ENEMY_SIZE
};

-- Debug Variables
DRAW_POSITIONS = false;
DRAW_BOXES = false;
DRAW_COUNTS = false;
KILL_PLAYER = false;GameState = require "lib/hump/gamestate";
Class = require "lib/hump/class";
Timer = require "lib/hump/timer";
Vector = require "lib/hump/vector";
Bump = require "lib/bump";

require "lib/general";
require "constants";

require "state/state-game";

BumpWorld = {};

function love.load()
  GameState.registerEvents();
  GameState.switch(State_Game);
end

function love.keypressed(key, scancode, isrepeat)
  if key == KEY_QUIT then
    love.event.quit();
  end
endPlayer = Class {
  init = function(self)
    self.box = {
      x = PLAYER_INITIAL_DIMENSIONS.x,
      y = PLAYER_INITIAL_DIMENSIONS.y,
      w = PLAYER_INITIAL_DIMENSIONS.w,
      h = PLAYER_INITIAL_DIMENSIONS.h
    };

    self.pickupBox = {
      x = PICKUP_BOX_INITIAL_DIMENSIONS.x,
      y = PICKUP_BOX_INITIAL_DIMENSIONS.y,
      w = PICKUP_BOX_INITIAL_DIMENSIONS.w,
      h = PICKUP_BOX_INITIAL_DIMENSIONS.h,
      type = "pickup-box"
    }

    BumpWorld:add(self, self.box.x, self.box.y, self.box.w, self.box.h);
    BumpWorld:add(self.pickupBox, self.pickupBox.x, self.pickupBox.y, self.pickupBox.w, self.pickupBox.h);

    self:resetKeys();

    self.velocity = { x = 0, y = 0 };
    self.facing = { x = 0, y = 0 };
    self.caughtBullets = {};
    self.health = PLAYER_MAX_HEALTH;

    self.streamTimer = Timer.new();

    self.active = true;
    self.type = "player";
  end
};

function Player:resetKeys()
  self.leftPressed = false;
  self.rightPressed = false;
  self.upPressed = false;
  self.downPressed = false;
  self.runPressed = false;

  self.streaming = false;
end

function Player:fireStream()
  if not self.streaming then
    local caughtBullets = self.caughtBullets;
    self.caughtBullets = {};

    self.streamTimer:script(function(wait)
      self.streaming = true;

      while #caughtBullets > 0 do
        caughtBullets[1]:throwStraight();
        table.remove(caughtBullets, 1);
        wait(0.2);
      end

      self.streaming = false;
    end);
  end
end

function Player:fireSpread()
  local caughtBullets = self.caughtBullets;
  self.caughtBullets = {};

  for index, bullet in ipairs(caughtBullets) do
    local angle = BULLET_SPREAD[index];
    bullet:throwSpread(angle);
  end
end

function Player:update(dt)
  if not self.active then
    return;
  end

  self.streamTimer:update(dt);
  self:updateVelocity();
  self:updateRotation();
  self:updatePosition(dt);
end

function Player:updateVelocity()
  local vx = 0;
  local vy = 0;

  if self.leftPressed then
    vx = vx - 1;
  end

  if self.rightPressed then
    vx = vx + 1;
  end

  if self.upPressed then
    vy = vy - 1;
  end

  if self.downPressed then
    vy = vy + 1;
  end

  if vx ~= 0 or vy ~= 0 then
    vx, vy = math.normalize(vx, vy);
  end

  self.velocity.x = vx * PLAYER_SPEED;
  self.velocity.y = vy * PLAYER_SPEED;
end

function Player:updateRotation()
  if self.velocity.x ~= 0 or self.velocity.y ~= 0 then
    local fx, fy = math.normalize(self.velocity.x, self.velocity.y);
    self.facing.x = fx;
    self.facing.y = fy;
  end
end

function Player:updatePosition(dt)
  local dx = self.box.x + self.velocity.x * dt;
  local dy = self.box.y + self.velocity.y * dt;

  dx = math.clamp(dx, 0, SCREEN_WIDTH - PLAYER_WIDTH);
  dy = math.clamp(dy, 0, SCREEN_HEIGHT - PLAYER_HEIGHT);

  local actualX, actualY, cols, len = BumpWorld:move(self, dx, dy, playerCollision);

  for i = 1, len do
    if cols[i].other.type == "bullet" then
      if KILL_PLAYER then
        self.health = self.health - 1;

        if self.health <= 0 then
          self.caughtBullets = {};
          self.active = false;
        end
      end
      cols[i].other.active = false;
    end
  end

  self.box.x = actualX;
  self.box.y = actualY;

  local pux = actualX + PLAYER_WIDTH / 2 - PICKUP_BOX_WIDTH / 2;
  local puy = actualY + PLAYER_HEIGHT / 2 - PICKUP_BOX_HEIGHT / 2;

  local actualX, actualY, cols, len = BumpWorld:move(self.pickupBox, pux, puy, pickupBoxCollision);

  for i = 1, len do
    if cols[i].other.type == "bullet-pickup" and not cols[i].other.pickedUp and not cols[i].other.thrown then
      if #self.caughtBullets < MAX_HELD_BULLETS then
        table.insert(self.caughtBullets, cols[i].other);
        cols[i].other:pickUp();
      else
        cols[i].other.active = false;
      end
    end
  end

  self.pickupBox.x = actualX;
  self.pickupBox.y = actualY;
end

function Player:draw()
  if not self.active then
    return;
  end

  love.graphics.setColor(255, 255, 255, 150);
  love.graphics.rectangle("line", self.pickupBox.x, self.pickupBox.y, self.pickupBox.w, self.pickupBox.h);

  love.graphics.setColor(0, 0, 255);
  love.graphics.rectangle("fill", self.box.x, self.box.y, self.box.w, self.box.h);

  -- Draw Health
  love.graphics.setColor(0, 255, 255);
  for i=1, self.health do
    love.graphics.rectangle("fill", i * 68, 16, 60, 32);
  end

  for i=self.health, PLAYER_MAX_HEALTH do
    love.graphics.rectangle("line", i * 68, 16, 60, 32);
  end

  if DRAW_BOXES then
    love.graphics.setColor(255, 255, 255);
    love.graphics.rectangle("line", BumpWorld:getRect(self));
  end
end# Game-Off-2017

# Hi there!!
You're here looking for JoeZ's entry into [Game Off 2017](https://itch.io/jam/game-off-2017), right? You're in the right place. Here you can follow my development and progress, look through the images and assets (when I get to them), and download and run the current version of my game.

When the game is all completed and packaged up, you'll be able to download it on [itch.io](http://itch.io/) or from this page through that "# releases" link up above.

## Running the game
Until the game is completed, here's how you can check out the "in progress" version of the game.

1. Download the appropriate version of [Love2D](http://love2d.org/) for your operating system. This game uses version 0.10.
2. Click the green "Clone or Download" button in the upper right of this page.
3. Click "Download Zip"
4. Unzip the folder. You should now have a folder called Game-Off-2017-master with some lua files, a couple folders, a README file and a RUNME file.
5. If you downloaded one of the installers during step 1 and are on Windows, just double-click the RUNME file to run the game.
6. If you downloaded one of the zip files during step 1, unzip it, find the love.exe or love.app file, and drag-and-drop the Game-Off-2017-master folder onto the love.exe or love.app file.
7. If all else fails, read the "Running Games" section on the [Love2D Wiki](http://love2d.org/wiki/Getting_Started)

After you've gone through this process once, you'll only need to repeat steps 2-7 to get and play the latest version of the game.

## Controls
The blue box is you. Use the arrow keys to move around. The grey box is your "tractor field" that will grab the yellow bullets for you. Press Z to fire all your grabbed bullets in a line. Press X to fire all your grabbed bullets in a spreading wave.

## Progress
If you're interested in a log of my progress, click on the "# commits" link in the upper-left of this page.

# My Notes
The theme this year is "throwback." I don't think I'm going to have a lot of time to work on this, so the simpler the better. Just a catch and throw game. Something similar to Breakout but with Tetris-style progression. Maybe something like Burger Time where you have to catch and throw things back into buckets in a certain order. Or a package sorter where you are pummeled by colored balls and you have to put them in the right buckets on the other side of the room. I want to try using a gamepad for this project, so the user will be able to aim using the joystick. I shouldn't rely on that though. WASD should still work for this. That means not restricting the player's movement and allowing them to move into the right position so that a cardinal direction would still allow them to aim.

I seem to be stuck on this food idea. I could have the person put together spaghetti and meatball meals. That can be put together in any order and needs pasta, meatballs, and sauce. 3 is a good number. I can also throw trash at the player. I just need to figure out how to ramp up the difficulty. I will either need hazards and some method of gradually preventing the player from building meals, or I can just add a flat timer and give them a star or score rating.

Is there any other game type where I can use a catch-and-throw mechanic and still have it be fun? Maybe this is the part where I start playing around with some mechanics.

Writing this down before I forget. I think the throwback theme would fit really well with a shoot ‚Äòem up style game where you don‚Äôt shoot on your own. Instead, you can catch certain types of bullets and bombs and throw them back.
love %cd%GAME_TIMELINE = {
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 160, y = -30}, {type = "straight", x = 416, y = -30}}},
  {time = 6, enemies = {{type = "pendulum", x = 200, y = -30}}},
  {time = 2, enemies = {{type = "pendulum", x = 200, y = -30}}},
  {time = 2, enemies = {{type = "pendulum", x = 200, y = -30}}},
  {time = 2, enemies = {{type = "pendulum", x = 200, y = -30}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}, {type = "straight", x = 192, y = -30}, {type = "straight", x = 384, y = -30}}},
  
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}},
  {time = 4, enemies = {{type = "straight", x = 288, y = -30}}},
  {time = 4, enemies = {{type = "sideways", x = 1, y = 288}}}
}

--{time = 2, enemies = {{type = "straight", x = 100, y = -30}}},
--{time = 2, enemies = {{type = "pendulum", x = 200, y = -30}}},
--{time = 2, enemies = {{type = "sideways", x = 1, y = 288}}}âPNG

   IHDR  X      ˇ`ƒ   sRGB ÆŒÈ   gAMA  ±è¸a   	pHYs  ¬  ¬(JÄ  *IDATx^Ì›ÌR€»@—Ù}ˇwÓk\3ô¿∂—«ZU™ÛR mün[„◊Ø_Ûr  ˘ﬂ˚ à, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	,aŒy= `∆ÂpWb∑E’ÀØ5 ¸, Äò	ápõdô^∞  fâ  &∞  b  &∞  b  &∞  b  &∞  b‡ã<d¯å¿ àyT¿<ö\y&pcÇ XÊ;L∞ æËvÛ5π:JæÀ‡ãñÆõ.à	 <`B…w, Äò%B Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	¨»úÛz  åÀ°
æ·QTç±¸≥ geÇ 3¡ä‹&Y¶W Ä¿ àY" à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿bìÊú◊ ˆh\w16„QTç±¸ö¿~ò` ?‚»´&Xl“ÌŒÙ
‡òÓ√Íh◊{, Äò¿bìñW2¶W Ïï¿ ^n˝"˙à/®óü»,‡iÏßŒ»xöı&÷£æS‡Å X¿”}è¿gÏ¡ àô` ƒ @L` ƒ @L` ƒºãÄMπˇPZÒ¡ô`∞iû¿	, 6Od±7  f õÙŸ‘ û,ˆ@`∞YÎ»VÏâ%B 6ÎU‚äΩ1¡ àô` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ∆Âòoß∞]s˛˛5c˘µÄÌ2¡bÛ÷qµ∏ˇ ∂F` ƒ @L`±y˜{ÆÏ¡`Îlr àô` ƒ @L` ƒ @L` ƒ @L` ƒ @L`l‘Ú`s7á}ÚIÓ Ù(¨<&
ˆ√  fÇ∞Q∑)ñ…Ïè	 @Ã  fÇ X  1Å X  1Å X  1Å X  1Å X  1Å X  ±”÷úÛz  <À∏ß©çGa5∆ÚO  –±D X  ±S-.nÀÑñÄg9]` <õ%B Äò¿ à	, Äò¿ à	, Äò¿ à	,‡Øxû'¿ü	,‡?[áï»¯ú¿ à	,‡?[?b „¶ >ÁQ9 ¿_Ûlﬂ'∞ ÄøÚh¶–˙»! @L` ƒ, Õ¨'∞  bñ b  &∞  b  &∞  b  &∞  b  ÊÉF˘ÎÖ˙` é∆ãóª
˚£ß≤¿û	, Äò¿‚ÂÓó-p4  fì; @Ã  &∞ xäÂ¬ﬁ%ÃYY" ˜(¨º°Ö31¡ àô`∑)ñ…g$∞  bñ b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  bÿî9Áı ÿ3Ål∆:¨D∞g  &∞ÄÕcºü}<ÿõÂ
f 2¡ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	,x±9Áı ‡∏º–:¨D¿q	, Äò¿Çcºü}<‡Xñ+ºu
 Äê	 @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @l\é˘v
 «7ÁÔ€ﬁÀmz&X ú∆:Æ˜_CE`Ìƒrp! Ä}∞D∏qè¢ H‡Î÷◊U◊SûE`mú¿Ä˝±D 3¡⁄â€$ÀÙ
 ∂O` )˚‹, °˚Ω√èˆüÅ¿ à	,  sø$x÷%B{∞ v»ÿ6,Äù±«∂O` ƒ @L`ÏåMƒ∞}6π ƒL∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b„rÃ∑S >3ÁÔKÂÀ•snﬂ˜ûæg8, Äò¿¯ÉıÙjqˇıV≠øœΩ|œp∏Zn¿∑ÄÔX¿?¢Jd}tøi/˚ô÷ﬂß=XZÀ_ú+)ú‹£†rC¯:,`∑Ä≠2¡ àô` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ @L` ƒ÷≈úÛz  NXÎ∞Y @¡  v˙¿cºü}< ¯*, Äÿ2≤±Ò  dÇ X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å ócæù¬vÕ˘Ò◊tåÂW ∂…  &∞ÿº˚È’‚—ˇÄ≠Xl⁄g!eâÄ-XÏé∏`Îª"Æ ÿÔ"dÛñeBa¿û, Äò%B Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äÿ∏ÛÌ éoŒﬂ∑Ω1ñ€ ÙL∞ 8çu\-ÓøÜä¿ à	, N„~I–!œ"∞  b6π ƒL∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞ ﬁÕ9Ø¿wçÀ·júﬁ£∞cπD¸=, Äò	¿ª€À‰
¯., Äò	 @Ã  &∞  b  &∞‡≈|ò%¿Ò	,x°uXâ,Ä„X ¿À‹¶¯Gë)∞  b^h˝	·>-8õ˚©’ëßX^l	+qpl xâ˚óG~±π¸dﬁ  2¡ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	,Äõs^‡µ¿A≠√Jd¡k	, Äò¿8®1∆˚Ÿ«s‡˘ @lyIca  dÇ X  1Å X  1Å X  1Å X  1Å X  1Åı√Êú◊ 8œ"¸Aè¬ Ô`ˇL∞  b&X?Ï6≈2πÄ„0¡ àô` ƒL∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  6.«|; ûaŒﬂ∑⁄1ñ[/GgÇ O¥é´≈˝◊ì¿ à	, x¢˚%AKÑÁ` @Ã  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  ∂€¿ös^ Ä≠ócWïÚ(™∆X~ Äm∞D X  ±›-ﬁ‹ñ
- [≥€¿ ÿ*KÑ  1,vk˝éRK≈ lâ	ªtˇq>Ä-X  1Å XÏ“˝û+{∞ ÿõ‹ b&X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X¿ÆÕ9Ø¿ñ, Äò¿vk=π2≈∂D` ƒ∞[cå˜≥èÁ ?mπ"ô´ ÑL∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  &∞  b  6.«|; ÿ∑9gÕKÊ¸, ‡÷qµ∏ˇ˙ï @L` ƒ p˜{Æ~rñMÓ  1, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿:Ä9Áı  ∂A`Ì‹:¨D lÉ¿ à	, Äò¿⁄π1∆˚Ÿ«s ‡Á,wdw  B&X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Åp2sŒÎ<œ∏˛  N‡QTç±‹Äö	 @L` ƒ,úÃm©–Ú <è¿ àY" à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äò¿ à	, Äÿ∏ÛÌt_Ê|˚∂«X~ ÿÜ€˝i·u^ª¨ı/Óç_` ∂¿=äKÑpÀEˇ—ÖÄÁÿ›ÎÊv≥  >Á’4ºﬁ˙ÔŒﬂ€yÌ6∞Ä?X ?C`¡	ò¯ºñ¿ àŸ‰ X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  1Å X  ©_ø˛WÍ71u∂=    IENDÆB`Ç<?xml version="1.0" encoding="UTF-8"?>
<map version="1.0" tiledversion="1.0.3" orientation="orthogonal" renderorder="right-down" width="19" height="25" tilewidth="32" tileheight="32" nextobjectid="42">
 <objectgroup color="#ff0000" name="Coordinates">
  <object id="1" x="288" y="0" width="32" height="32"/>
  <object id="5" x="0" y="288" width="32" height="32"/>
  <object id="6" x="32" y="256" width="32" height="32"/>
  <object id="7" x="64" y="224" width="32" height="32"/>
  <object id="8" x="96" y="192" width="32" height="32"/>
  <object id="9" x="128" y="160" width="32" height="32"/>
  <object id="10" x="160" y="128" width="32" height="32"/>
  <object id="11" x="192" y="96" width="32" height="32"/>
  <object id="12" x="224" y="64" width="32" height="32"/>
  <object id="13" x="256" y="32" width="32" height="32"/>
  <object id="14" x="320" y="32" width="32" height="32"/>
  <object id="15" x="352" y="64" width="32" height="32"/>
  <object id="16" x="384" y="96" width="32" height="32"/>
  <object id="17" x="416" y="128" width="32" height="32"/>
  <object id="18" x="448" y="160" width="32" height="32"/>
  <object id="19" x="480" y="192" width="32" height="32"/>
  <object id="20" x="512" y="224" width="32" height="32"/>
  <object id="21" x="544" y="256" width="32" height="32"/>
  <object id="22" x="576" y="288" width="32" height="32"/>
  <object id="24" x="288" y="576" width="32" height="32"/>
  <object id="25" x="352" y="512" width="32" height="32"/>
  <object id="26" x="64" y="352" width="32" height="32"/>
  <object id="27" x="128" y="416" width="32" height="32"/>
  <object id="28" x="224" y="512" width="32" height="32"/>
  <object id="29" x="544" y="320" width="32" height="32"/>
  <object id="30" x="512" y="352" width="32" height="32"/>
  <object id="31" x="480" y="384" width="32" height="32"/>
  <object id="32" x="192" y="480" width="32" height="32"/>
  <object id="33" x="160" y="448" width="32" height="32"/>
  <object id="35" x="320" y="544" width="32" height="32"/>
  <object id="36" x="416" y="448" width="32" height="32"/>
  <object id="37" x="32" y="320" width="32" height="32"/>
  <object id="38" x="96" y="384" width="32" height="32"/>
  <object id="39" x="256" y="544" width="32" height="32"/>
  <object id="40" x="448" y="416" width="32" height="32"/>
  <object id="41" x="384" y="480" width="32" height="32"/>
 </objectgroup>
</map>
EnemyPendulum = Class {
  init = function(self, x, y, weaponManager)
    self.box = {
      x = x,
      y = y,
      w = PENDULUM_ENEMY_INITIAL_DIMENSIONS.w,
      h = PENDULUM_ENEMY_INITIAL_DIMENSIONS.h
    };

    BumpWorld:add(self, self.box.x, self.box.y, self.box.w, self.box.h);

    self.fireTimer = Timer.new();
    self.weaponManager = weaponManager;
    self.moveTimer = 0;

    self.fireTimer:every(2.5, function() self:fireBullets() end);

    self.active = true;
    self.type = "enemy";
  end
};

function EnemyPendulum:fireBullets()
  self.fireTimer:script(function(wait)
    for i = 1, 5 do
      self:fireBullet(i);
      wait(0.1);
    end
  end);
end

function EnemyPendulum:fireBullet(index)
  local type = "bullet";
  if index == 5 then
    type = "bullet-pickup";
  end

  local bx = self.box.x + self.box.w / 2 - BULLET_SIZE;
  local by = self.box.y + self.box.h / 2 - BULLET_SIZE;
  self.weaponManager:spawnBullet(bx, by, type);
end

function EnemyPendulum:update(dt)
  if not self.active then
    return;
  end

  self.fireTimer:update(dt);
  self.moveTimer = self.moveTimer + dt;
  local dx = cerp(PENDULUM_ENEMY_LEFT_LIMIT, PENDULUM_ENEMY_RIGHT_LIMIT, self.moveTimer / PENDULUM_ENEMY_MOVEMENT_RATE);
  local dy = self.box.y + PENDULUM_ENEMY_SPEED * dt;

  if self.moveTimer > PENDULUM_ENEMY_MOVEMENT_RATE * 2 then
    self.moveTimer = 0;
  end

  local actualX, actualY, cols, len = BumpWorld:move(self, dx, dy, enemyCollision);

  self.box.x = actualX;
  self.box.y = actualY;

  if self.box.y > SCREEN_HEIGHT then
    self.active = false;
    return;
  end

  for i = 1, len do
    if cols[i].other.type == "bullet-pickup" and cols[i].other.thrown then
      self.active = false;
      cols[i].other.active = false;
    end
  end
end

function EnemyPendulum:draw()
  if not self.active then
    return;
  end

  love.graphics.setColor(255, 0, 0);
  love.graphics.rectangle("fill", self.box.x, self.box.y, self.box.w, self.box.h);

  if DRAW_BOXES then
    love.graphics.setColor(255, 255, 255);
    love.graphics.rectangle("line", BumpWorld:getRect(self));
  end
endEnemySideways = Class {
  init = function(self, direction, y, weaponManager)
    self.box = {
      x = 0,
      y = y,
      w = SIDEWAYS_ENEMY_INITIAL_DIMENSIONS.w,
      h = SIDEWAYS_ENEMY_INITIAL_DIMENSIONS.h
    };

    self.direction = direction;
    if direction == -1 then
      self.box.x = SCREEN_WIDTH;
    else
      self.box.x = -self.box.w;
    end

    BumpWorld:add(self, self.box.x, self.box.y, self.box.w, self.box.h);

    self.fireTimer = Timer.new();
    self.bulletIndex = 0;
    self.weaponManager = weaponManager;

    self.fireTimer:every(SIDEWAYS_ENEMY_FIRE_RATE, function() self:fireBullet() end);

    self.active = true;
    self.type = "enemy";
  end
};

function EnemySideways:fireBullet()
  local type = "bullet";
  self.bulletIndex = self.bulletIndex + 1;
  if self.bulletIndex % 2 == 1 then
    type = "bullet-pickup";
  end

  local bx = self.box.x + self.box.w / 2 - BULLET_SIZE;
  local by = self.box.y + self.box.h / 2 - BULLET_SIZE;
  self.weaponManager:spawnBullet(bx, by, type);
end

function EnemySideways:update(dt)
  if not self.active then
    return;
  end

  self.fireTimer:update(dt);
  local dx = self.box.x + SIDEWAYS_ENEMY_SPEED * dt * self.direction;

  local actualX, actualY, cols, len = BumpWorld:move(self, dx, self.box.y, enemyCollision);

  self.box.x = actualX;
  self.box.y = actualY;

  if (self.box.x < 0 - self.box.w and self.direction == -1) or (self.box.x > SCREEN_WIDTH and self.direction == 1) then
    self.active = false;
    return;
  end

  for i = 1, len do
    if cols[i].other.type == "bullet-pickup" and cols[i].other.thrown then
      self.active = false;
      cols[i].other.active = false;
    end
  end
end

function EnemySideways:draw()
  if not self.active then
    return;
  end

  love.graphics.setColor(0, 0, 150);
  love.graphics.rectangle("fill", self.box.x, self.box.y, self.box.w, self.box.h);

  if DRAW_BOXES then
    love.graphics.setColor(255, 255, 255);
    love.graphics.rectangle("line", BumpWorld:getRect(self));
  end
endEnemyStraight = Class {
  init = function(self, x, y, weaponManager)
    self.box = {
      x = x,
      y = y,
      w = STRAIGHT_ENEMY_INITIAL_DIMENSIONS.w,
      h = STRAIGHT_ENEMY_INITIAL_DIMENSIONS.h
    };

    BumpWorld:add(self, self.box.x, self.box.y, self.box.w, self.box.h);

    self.fireTimer = Timer.new();
    self.bulletIndex = 0;
    self.weaponManager = weaponManager;

    self.fireTimer:every(STRAIGHT_ENEMY_FIRE_RATE, function() self:fireBullet() end);

    self.active = true;
    self.type = "enemy";
  end
};

function EnemyStraight:fireBullet()
  local type = "bullet";
  self.bulletIndex = self.bulletIndex + 1;
  if self.bulletIndex % 2 == 1 then
    type = "bullet-pickup";
  end

  local bx = self.box.x + self.box.w / 2 - BULLET_SIZE;
  local by = self.box.y + self.box.h / 2 - BULLET_SIZE;
  self.weaponManager:spawnBullet(bx, by, type);
end

function EnemyStraight:update(dt)
  if not self.active then
    return;
  end

  self.fireTimer:update(dt);
  local dy = self.box.y + STRAIGHT_ENEMY_SPEED * dt;

  local actualX, actualY, cols, len = BumpWorld:move(self, self.box.x, dy, enemyCollision);

  self.box.x = actualX;
  self.box.y = actualY;

  if self.box.y > SCREEN_HEIGHT then
    self.active = false;
    return;
  end

  for i = 1, len do
    if cols[i].other.type == "bullet-pickup" and cols[i].other.thrown then
      self.active = false;
      cols[i].other.active = false;
    end
  end
end

function EnemyStraight:draw()
  if not self.active then
    return;
  end

  love.graphics.setColor(0, 150, 0);
  love.graphics.rectangle("fill", self.box.x, self.box.y, self.box.w, self.box.h);

  if DRAW_BOXES then
    love.graphics.setColor(255, 255, 255);
    love.graphics.rectangle("line", BumpWorld:getRect(self));
  end
endrequire "enemy/enemy-straight";
require "enemy/enemy-pendulum";
require "enemy/enemy-sideways";

ManagerEnemy = Class {
  init = function(self, weaponManager)
    self.weaponManager = weaponManager;
    self.enemies = {};
  end
};

function ManagerEnemy:spawnEnemy(enemy)
  if enemy.type == "straight" then
    table.insert(self.enemies, EnemyStraight(enemy.x, enemy.y, self.weaponManager));
  elseif enemy.type == "sideways" then
    table.insert(self.enemies, EnemySideways(enemy.x, enemy.y, self.weaponManager));
  elseif enemy.type == "pendulum" then
    table.insert(self.enemies, EnemyPendulum(enemy.x, enemy.y, self.weaponManager));
  end
end

function ManagerEnemy:update(dt)
  local activeEnemies = {};

  for index, enemy in ipairs(self.enemies) do
    enemy:update(dt, self.player);

    if enemy.active then
      table.insert(activeEnemies, enemy);
    end
  end

  self.enemies = activeEnemies;
end

function ManagerEnemy:draw()
  for index, enemy in ipairs(self.enemies) do
    enemy:draw();
  end

  if DRAW_COUNTS then
    love.graphics.setColor(255, 255, 255);
    love.graphics.print("Enemies: " .. #self.enemies, 32, 60);
  end
endlocal anim8 = {
  _VERSION     = 'anim8 v2.3.1',
  _DESCRIPTION = 'An animation library for L√ñVE',
  _URL         = 'https://github.com/kikito/anim8',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2011 Enrique Garc√≠a Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

local Grid = {}

local _frames = {}

local function assertPositiveInteger(value, name)
  if type(value) ~= 'number' then error(("%s should be a number, was %q"):format(name, tostring(value))) end
  if value < 1 then error(("%s should be a positive number, was %d"):format(name, value)) end
  if value ~= math.floor(value) then error(("%s should be an integer, was %d"):format(name, value)) end
end

local function createFrame(self, x, y)
  local fw, fh = self.frameWidth, self.frameHeight
  return love.graphics.newQuad(
    self.left + (x-1) * fw + x * self.border,
    self.top  + (y-1) * fh + y * self.border,
    fw,
    fh,
    self.imageWidth,
    self.imageHeight
  )
end

local function getGridKey(...)
  return table.concat( {...} ,'-' )
end

local function getOrCreateFrame(self, x, y)
  if x < 1 or x > self.width or y < 1 or y > self.height then
    error(("There is no frame for x=%d, y=%d"):format(x, y))
  end
  local key = self._key
  _frames[key]       = _frames[key]       or {}
  _frames[key][x]    = _frames[key][x]    or {}
  _frames[key][x][y] = _frames[key][x][y] or createFrame(self, x, y)
  return _frames[key][x][y]
end

local function parseInterval(str)
  if type(str) == "number" then return str,str,1 end
  str = str:gsub('%s', '') -- remove spaces
  local min, max = str:match("^(%d+)-(%d+)$")
  assert(min and max, ("Could not parse interval from %q"):format(str))
  min, max = tonumber(min), tonumber(max)
  local step = min <= max and 1 or -1
  return min, max, step
end

function Grid:getFrames(...)
  local result, args = {}, {...}
  local minx, maxx, stepx, miny, maxy, stepy

  for i=1, #args, 2 do
    minx, maxx, stepx = parseInterval(args[i])
    miny, maxy, stepy = parseInterval(args[i+1])
    for y = miny, maxy, stepy do
      for x = minx, maxx, stepx do
        result[#result+1] = getOrCreateFrame(self,x,y)
      end
    end
  end

  return result
end

local Gridmt = {
  __index = Grid,
  __call  = Grid.getFrames
}

local function newGrid(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)
  assertPositiveInteger(frameWidth,  "frameWidth")
  assertPositiveInteger(frameHeight, "frameHeight")
  assertPositiveInteger(imageWidth,  "imageWidth")
  assertPositiveInteger(imageHeight, "imageHeight")

  left   = left   or 0
  top    = top    or 0
  border = border or 0

  local key  = getGridKey(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)

  local grid = setmetatable(
    { frameWidth  = frameWidth,
      frameHeight = frameHeight,
      imageWidth  = imageWidth,
      imageHeight = imageHeight,
      left        = left,
      top         = top,
      border      = border,
      width       = math.floor(imageWidth/frameWidth),
      height      = math.floor(imageHeight/frameHeight),
      _key        = key
    },
    Gridmt
  )
  return grid
end

-----------------------------------------------------------

local Animation = {}

local function cloneArray(arr)
  local result = {}
  for i=1,#arr do result[i] = arr[i] end
  return result
end

local function parseDurations(durations, frameCount)
  local result = {}
  if type(durations) == 'number' then
    for i=1,frameCount do result[i] = durations end
  else
    local min, max, step
    for key,duration in pairs(durations) do
      assert(type(duration) == 'number', "The value [" .. tostring(duration) .. "] should be a number")
      min, max, step = parseInterval(key)
      for i = min,max,step do result[i] = duration end
    end
  end

  if #result < frameCount then
    error("The durations table has length of " .. tostring(#result) .. ", but it should be >= " .. tostring(frameCount))
  end

  return result
end

local function parseIntervals(durations)
  local result, time = {0},0
  for i=1,#durations do
    time = time + durations[i]
    result[i+1] = time
  end
  return result, time
end

local Animationmt = { __index = Animation }
local nop = function() end

local function newAnimation(frames, durations, onLoop)
  local td = type(durations);
  if (td ~= 'number' or durations <= 0) and td ~= 'table' then
    error("durations must be a positive number. Was " .. tostring(durations) )
  end
  onLoop = onLoop or nop
  durations = parseDurations(durations, #frames)
  local intervals, totalDuration = parseIntervals(durations)
  return setmetatable({
      frames         = cloneArray(frames),
      durations      = durations,
      intervals      = intervals,
      totalDuration  = totalDuration,
      onLoop         = onLoop,
      timer          = 0,
      position       = 1,
      status         = "playing",
      flippedH       = false,
      flippedV       = false
    },
    Animationmt
  )
end

function Animation:clone()
  local newAnim = newAnimation(self.frames, self.durations, self.onLoop)
  newAnim.flippedH, newAnim.flippedV = self.flippedH, self.flippedV
  return newAnim
end

function Animation:flipH()
  self.flippedH = not self.flippedH
  return self
end

function Animation:flipV()
  self.flippedV = not self.flippedV
  return self
end

local function seekFrameIndex(intervals, timer)
  local high, low, i = #intervals-1, 1, 1

  while(low <= high) do
    i = math.floor((low + high) / 2)
    if     timer >= intervals[i+1] then low  = i + 1
    elseif timer <  intervals[i]   then high = i - 1
    else
      return i
    end
  end

  return i
end

function Animation:update(dt)
  if self.status ~= "playing" then return end

  self.timer = self.timer + dt
  local loops = math.floor(self.timer / self.totalDuration)
  if loops ~= 0 then
    self.timer = self.timer - self.totalDuration * loops
    local f = type(self.onLoop) == 'function' and self.onLoop or self[self.onLoop]
    f(self, loops)
  end

  self.position = seekFrameIndex(self.intervals, self.timer)
end

function Animation:pause()
  self.status = "paused"
end

function Animation:gotoFrame(position)
  self.position = position
  self.timer = self.intervals[self.position]
end

function Animation:pauseAtEnd()
  self.position = #self.frames
  self.timer = self.totalDuration
  self:pause()
end

function Animation:pauseAtStart()
  self.position = 1
  self.timer = 0
  self:pause()
end

function Animation:resume()
  self.status = "playing"
end

function Animation:draw(image, x, y, r, sx, sy, ox, oy, kx, ky)
  love.graphics.draw(image, self:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky))
end

function Animation:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky)
  local frame = self.frames[self.position]
  if self.flippedH or self.flippedV then
    r,sx,sy,ox,oy,kx,ky = r or 0, sx or 1, sy or 1, ox or 0, oy or 0, kx or 0, ky or 0
    local _,_,w,h = frame:getViewport()

    if self.flippedH then
      sx = sx * -1
      ox = w - ox
      kx = kx * -1
      ky = ky * -1
    end

    if self.flippedV then
      sy = sy * -1
      oy = h - oy
      kx = kx * -1
      ky = ky * -1
    end
  end
  return frame, x, y, r, sx, sy, ox, oy, kx, ky
end

function Animation:getDimensions()
  local _,_,w,h = self.frames[self.position]:getViewport()
  return w,h
end

-----------------------------------------------------------

anim8.newGrid       = newGrid
anim8.newAnimation  = newAnimation

return anim8
local bump = {
  _VERSION     = 'bump v3.1.7',
  _URL         = 'https://github.com/kikito/bump.lua',
  _DESCRIPTION = 'A collision detection library for Lua',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2014 Enrique GarcÌa Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

------------------------------------------
-- Auxiliary functions
------------------------------------------
local DELTA = 1e-10 -- floating-point margin of error

local abs, floor, ceil, min, max = math.abs, math.floor, math.ceil, math.min, math.max

local function sign(x)
  if x > 0 then return 1 end
  if x == 0 then return 0 end
  return -1
end

local function nearest(x, a, b)
  if abs(a - x) < abs(b - x) then return a else return b end
end

local function assertType(desiredType, value, name)
  if type(value) ~= desiredType then
    error(name .. ' must be a ' .. desiredType .. ', but was ' .. tostring(value) .. '(a ' .. type(value) .. ')')
  end
end

local function assertIsPositiveNumber(value, name)
  if type(value) ~= 'number' or value <= 0 then
    error(name .. ' must be a positive integer, but was ' .. tostring(value) .. '(' .. type(value) .. ')')
  end
end

local function assertIsRect(x,y,w,h)
  assertType('number', x, 'x')
  assertType('number', y, 'y')
  assertIsPositiveNumber(w, 'w')
  assertIsPositiveNumber(h, 'h')
end

local defaultFilter = function()
  return 'slide'
end

------------------------------------------
-- Rectangle functions
------------------------------------------

local function rect_getNearestCorner(x,y,w,h, px, py)
  return nearest(px, x, x+w), nearest(py, y, y+h)
end

-- This is a generalized implementation of the liang-barsky algorithm, which also returns
-- the normals of the sides where the segment intersects.
-- Returns nil if the segment never touches the rect
-- Notice that normals are only guaranteed to be accurate when initially ti1, ti2 == -math.huge, math.huge
local function rect_getSegmentIntersectionIndices(x,y,w,h, x1,y1,x2,y2, ti1,ti2)
  ti1, ti2 = ti1 or 0, ti2 or 1
  local dx, dy = x2-x1, y2-y1
  local nx, ny
  local nx1, ny1, nx2, ny2 = 0,0,0,0
  local p, q, r

  for side = 1,4 do
    if     side == 1 then nx,ny,p,q = -1,  0, -dx, x1 - x     -- left
    elseif side == 2 then nx,ny,p,q =  1,  0,  dx, x + w - x1 -- right
    elseif side == 3 then nx,ny,p,q =  0, -1, -dy, y1 - y     -- top
    else                  nx,ny,p,q =  0,  1,  dy, y + h - y1 -- bottom
    end

    if p == 0 then
      if q <= 0 then return nil end
    else
      r = q / p
      if p < 0 then
        if     r > ti2 then return nil
        elseif r > ti1 then ti1,nx1,ny1 = r,nx,ny
        end
      else -- p > 0
        if     r < ti1 then return nil
        elseif r < ti2 then ti2,nx2,ny2 = r,nx,ny
        end
      end
    end
  end

  return ti1,ti2, nx1,ny1, nx2,ny2
end

-- Calculates the minkowsky difference between 2 rects, which is another rect
local function rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)
  return x2 - x1 - w1,
         y2 - y1 - h1,
         w1 + w2,
         h1 + h2
end

local function rect_containsPoint(x,y,w,h, px,py)
  return px - x > DELTA      and py - y > DELTA and
         x + w - px > DELTA  and y + h - py > DELTA
end

local function rect_isIntersecting(x1,y1,w1,h1, x2,y2,w2,h2)
  return x1 < x2+w2 and x2 < x1+w1 and
         y1 < y2+h2 and y2 < y1+h1
end

local function rect_getSquareDistance(x1,y1,w1,h1, x2,y2,w2,h2)
  local dx = x1 - x2 + (w1 - w2)/2
  local dy = y1 - y2 + (h1 - h2)/2
  return dx*dx + dy*dy
end

local function rect_detectCollision(x1,y1,w1,h1, x2,y2,w2,h2, goalX, goalY)
  goalX = goalX or x1
  goalY = goalY or y1

  local dx, dy      = goalX - x1, goalY - y1
  local x,y,w,h     = rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)

  local overlaps, ti, nx, ny

  if rect_containsPoint(x,y,w,h, 0,0) then -- item was intersecting other
    local px, py    = rect_getNearestCorner(x,y,w,h, 0, 0)
    local wi, hi    = min(w1, abs(px)), min(h1, abs(py)) -- area of intersection
    ti              = -wi * hi -- ti is the negative area of intersection
    overlaps = true
  else
    local ti1,ti2,nx1,ny1 = rect_getSegmentIntersectionIndices(x,y,w,h, 0,0,dx,dy, -math.huge, math.huge)

    -- item tunnels into other
    if ti1
    and ti1 < 1
    and (abs(ti1 - ti2) >= DELTA) -- special case for rect going through another rect's corner
    and (0 < ti1 + DELTA
      or 0 == ti1 and ti2 > 0)
    then
      ti, nx, ny = ti1, nx1, ny1
      overlaps   = false
    end
  end

  if not ti then return end

  local tx, ty

  if overlaps then
    if dx == 0 and dy == 0 then
      -- intersecting and not moving - use minimum displacement vector
      local px, py = rect_getNearestCorner(x,y,w,h, 0,0)
      if abs(px) < abs(py) then py = 0 else px = 0 end
      nx, ny = sign(px), sign(py)
      tx, ty = x1 + px, y1 + py
    else
      -- intersecting and moving - move in the opposite direction
      local ti1, _
      ti1,_,nx,ny = rect_getSegmentIntersectionIndices(x,y,w,h, 0,0,dx,dy, -math.huge, 1)
      if not ti1 then return end
      tx, ty = x1 + dx * ti1, y1 + dy * ti1
    end
  else -- tunnel
    tx, ty = x1 + dx * ti, y1 + dy * ti
  end

  return {
    overlaps  = overlaps,
    ti        = ti,
    move      = {x = dx, y = dy},
    normal    = {x = nx, y = ny},
    touch     = {x = tx, y = ty},
    itemRect  = {x = x1, y = y1, w = w1, h = h1},
    otherRect = {x = x2, y = y2, w = w2, h = h2}
  }
end

------------------------------------------
-- Grid functions
------------------------------------------

local function grid_toWorld(cellSize, cx, cy)
  return (cx - 1)*cellSize, (cy-1)*cellSize
end

local function grid_toCell(cellSize, x, y)
  return floor(x / cellSize) + 1, floor(y / cellSize) + 1
end

-- grid_traverse* functions are based on "A Fast Voxel Traversal Algorithm for Ray Tracing",
-- by John Amanides and Andrew Woo - http://www.cse.yorku.ca/~amana/research/grid.pdf
-- It has been modified to include both cells when the ray "touches a grid corner",
-- and with a different exit condition

local function grid_traverse_initStep(cellSize, ct, t1, t2)
  local v = t2 - t1
  if     v > 0 then
    return  1,  cellSize / v, ((ct + v) * cellSize - t1) / v
  elseif v < 0 then
    return -1, -cellSize / v, ((ct + v - 1) * cellSize - t1) / v
  else
    return 0, math.huge, math.huge
  end
end

local function grid_traverse(cellSize, x1,y1,x2,y2, f)
  local cx1,cy1        = grid_toCell(cellSize, x1,y1)
  local cx2,cy2        = grid_toCell(cellSize, x2,y2)
  local stepX, dx, tx  = grid_traverse_initStep(cellSize, cx1, x1, x2)
  local stepY, dy, ty  = grid_traverse_initStep(cellSize, cy1, y1, y2)
  local cx,cy          = cx1,cy1

  f(cx, cy)

  -- The default implementation had an infinite loop problem when
  -- approaching the last cell in some occassions. We finish iterating
  -- when we are *next* to the last cell
  while abs(cx - cx2) + abs(cy - cy2) > 1 do
    if tx < ty then
      tx, cx = tx + dx, cx + stepX
      f(cx, cy)
    else
      -- Addition: include both cells when going through corners
      if tx == ty then f(cx + stepX, cy) end
      ty, cy = ty + dy, cy + stepY
      f(cx, cy)
    end
  end

  -- If we have not arrived to the last cell, use it
  if cx ~= cx2 or cy ~= cy2 then f(cx2, cy2) end

end

local function grid_toCellRect(cellSize, x,y,w,h)
  local cx,cy = grid_toCell(cellSize, x, y)
  local cr,cb = ceil((x+w) / cellSize), ceil((y+h) / cellSize)
  return cx, cy, cr - cx + 1, cb - cy + 1
end

------------------------------------------
-- Responses
------------------------------------------

local touch = function(world, col, x,y,w,h, goalX, goalY, filter)
  return col.touch.x, col.touch.y, {}, 0
end

local cross = function(world, col, x,y,w,h, goalX, goalY, filter)
  local cols, len = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

local slide = function(world, col, x,y,w,h, goalX, goalY, filter)
  goalX = goalX or x
  goalY = goalY or y

  local tch, move  = col.touch, col.move
  local sx, sy     = tch.x, tch.y
  if move.x ~= 0 or move.y ~= 0 then
    if col.normal.x == 0 then
      sx = goalX
    else
      sy = goalY
    end
  end

  col.slide = {x = sx, y = sy}

  x,y          = tch.x, tch.y
  goalX, goalY = sx, sy
  local cols, len  = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

local bounce = function(world, col, x,y,w,h, goalX, goalY, filter)
  goalX = goalX or x
  goalY = goalY or y

  local tch, move = col.touch, col.move
  local tx, ty = tch.x, tch.y

  local bx, by = tx, ty

  if move.x ~= 0 or move.y ~= 0 then
    local bnx, bny = goalX - tx, goalY - ty
    if col.normal.x == 0 then bny = -bny else bnx = -bnx end
    bx, by = tx + bnx, ty + bny
  end

  col.bounce   = {x = bx,  y = by}
  x,y          = tch.x, tch.y
  goalX, goalY = bx, by

  local cols, len    = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

------------------------------------------
-- World
------------------------------------------

local World = {}
local World_mt = {__index = World}

-- Private functions and methods

local function sortByWeight(a,b) return a.weight < b.weight end

local function sortByTiAndDistance(a,b)
  if a.ti == b.ti then
    local ir, ar, br = a.itemRect, a.otherRect, b.otherRect
    local ad = rect_getSquareDistance(ir.x,ir.y,ir.w,ir.h, ar.x,ar.y,ar.w,ar.h)
    local bd = rect_getSquareDistance(ir.x,ir.y,ir.w,ir.h, br.x,br.y,br.w,br.h)
    return ad < bd
  end
  return a.ti < b.ti
end

local function addItemToCell(self, item, cx, cy)
  self.rows[cy] = self.rows[cy] or setmetatable({}, {__mode = 'v'})
  local row = self.rows[cy]
  row[cx] = row[cx] or {itemCount = 0, x = cx, y = cy, items = setmetatable({}, {__mode = 'k'})}
  local cell = row[cx]
  self.nonEmptyCells[cell] = true
  if not cell.items[item] then
    cell.items[item] = true
    cell.itemCount = cell.itemCount + 1
  end
end

local function removeItemFromCell(self, item, cx, cy)
  local row = self.rows[cy]
  if not row or not row[cx] or not row[cx].items[item] then return false end

  local cell = row[cx]
  cell.items[item] = nil
  cell.itemCount = cell.itemCount - 1
  if cell.itemCount == 0 then
    self.nonEmptyCells[cell] = nil
  end
  return true
end

local function getDictItemsInCellRect(self, cl,ct,cw,ch)
  local items_dict = {}
  for cy=ct,ct+ch-1 do
    local row = self.rows[cy]
    if row then
      for cx=cl,cl+cw-1 do
        local cell = row[cx]
        if cell and cell.itemCount > 0 then -- no cell.itemCount > 1 because tunneling
          for item,_ in pairs(cell.items) do
            items_dict[item] = true
          end
        end
      end
    end
  end

  return items_dict
end

local function getCellsTouchedBySegment(self, x1,y1,x2,y2)

  local cells, cellsLen, visited = {}, 0, {}

  grid_traverse(self.cellSize, x1,y1,x2,y2, function(cx, cy)
    local row  = self.rows[cy]
    if not row then return end
    local cell = row[cx]
    if not cell or visited[cell] then return end

    visited[cell] = true
    cellsLen = cellsLen + 1
    cells[cellsLen] = cell
  end)

  return cells, cellsLen
end

local function getInfoAboutItemsTouchedBySegment(self, x1,y1, x2,y2, filter)
  local cells, len = getCellsTouchedBySegment(self, x1,y1,x2,y2)
  local cell, rect, l,t,w,h, ti1,ti2, tii0,tii1
  local visited, itemInfo, itemInfoLen = {},{},0
  for i=1,len do
    cell = cells[i]
    for item in pairs(cell.items) do
      if not visited[item] then
        visited[item]  = true
        if (not filter or filter(item)) then
          rect           = self.rects[item]
          l,t,w,h        = rect.x,rect.y,rect.w,rect.h

          ti1,ti2 = rect_getSegmentIntersectionIndices(l,t,w,h, x1,y1, x2,y2, 0, 1)
          if ti1 and ((0 < ti1 and ti1 < 1) or (0 < ti2 and ti2 < 1)) then
            -- the sorting is according to the t of an infinite line, not the segment
            tii0,tii1    = rect_getSegmentIntersectionIndices(l,t,w,h, x1,y1, x2,y2, -math.huge, math.huge)
            itemInfoLen  = itemInfoLen + 1
            itemInfo[itemInfoLen] = {item = item, ti1 = ti1, ti2 = ti2, weight = min(tii0,tii1)}
          end
        end
      end
    end
  end
  table.sort(itemInfo, sortByWeight)
  return itemInfo, itemInfoLen
end

local function getResponseByName(self, name)
  local response = self.responses[name]
  if not response then
    error(('Unknown collision type: %s (%s)'):format(name, type(name)))
  end
  return response
end


-- Misc Public Methods

function World:addResponse(name, response)
  self.responses[name] = response
end

function World:project(item, x,y,w,h, goalX, goalY, filter)
  assertIsRect(x,y,w,h)

  goalX = goalX or x
  goalY = goalY or y
  filter  = filter  or defaultFilter

  local collisions, len = {}, 0

  local visited = {}
  if item ~= nil then visited[item] = true end

  -- This could probably be done with less cells using a polygon raster over the cells instead of a
  -- bounding rect of the whole movement. Conditional to building a queryPolygon method
  local tl, tt = min(goalX, x),       min(goalY, y)
  local tr, tb = max(goalX + w, x+w), max(goalY + h, y+h)
  local tw, th = tr-tl, tb-tt

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, tl,tt,tw,th)

  local dictItemsInCellRect = getDictItemsInCellRect(self, cl,ct,cw,ch)

  for other,_ in pairs(dictItemsInCellRect) do
    if not visited[other] then
      visited[other] = true

      local responseName = filter(item, other)
      if responseName then
        local ox,oy,ow,oh   = self:getRect(other)
        local col           = rect_detectCollision(x,y,w,h, ox,oy,ow,oh, goalX, goalY)

        if col then
          col.other    = other
          col.item     = item
          col.type     = responseName

          len = len + 1
          collisions[len] = col
        end
      end
    end
  end

  table.sort(collisions, sortByTiAndDistance)

  return collisions, len
end

function World:countCells()
  local count = 0
  for _,row in pairs(self.rows) do
    for _,_ in pairs(row) do
      count = count + 1
    end
  end
  return count
end

function World:hasItem(item)
  return not not self.rects[item]
end

function World:getItems()
  local items, len = {}, 0
  for item,_ in pairs(self.rects) do
    len = len + 1
    items[len] = item
  end
  return items, len
end

function World:countItems()
  local len = 0
  for _ in pairs(self.rects) do len = len + 1 end
  return len
end

function World:getRect(item)
  local rect = self.rects[item]
  if not rect then
    error('Item ' .. tostring(item) .. ' must be added to the world before getting its rect. Use world:add(item, x,y,w,h) to add it first.')
  end
  return rect.x, rect.y, rect.w, rect.h
end

function World:toWorld(cx, cy)
  return grid_toWorld(self.cellSize, cx, cy)
end

function World:toCell(x,y)
  return grid_toCell(self.cellSize, x, y)
end


--- Query methods

function World:queryRect(x,y,w,h, filter)

  assertIsRect(x,y,w,h)

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  local dictItemsInCellRect = getDictItemsInCellRect(self, cl,ct,cw,ch)

  local items, len = {}, 0

  local rect
  for item,_ in pairs(dictItemsInCellRect) do
    rect = self.rects[item]
    if (not filter or filter(item))
    and rect_isIntersecting(x,y,w,h, rect.x, rect.y, rect.w, rect.h)
    then
      len = len + 1
      items[len] = item
    end
  end

  return items, len
end

function World:queryPoint(x,y, filter)
  local cx,cy = self:toCell(x,y)
  local dictItemsInCellRect = getDictItemsInCellRect(self, cx,cy,1,1)

  local items, len = {}, 0

  local rect
  for item,_ in pairs(dictItemsInCellRect) do
    rect = self.rects[item]
    if (not filter or filter(item))
    and rect_containsPoint(rect.x, rect.y, rect.w, rect.h, x, y)
    then
      len = len + 1
      items[len] = item
    end
  end

  return items, len
end

function World:querySegment(x1, y1, x2, y2, filter)
  local itemInfo, len = getInfoAboutItemsTouchedBySegment(self, x1, y1, x2, y2, filter)
  local items = {}
  for i=1, len do
    items[i] = itemInfo[i].item
  end
  return items, len
end

function World:querySegmentWithCoords(x1, y1, x2, y2, filter)
  local itemInfo, len = getInfoAboutItemsTouchedBySegment(self, x1, y1, x2, y2, filter)
  local dx, dy        = x2-x1, y2-y1
  local info, ti1, ti2
  for i=1, len do
    info  = itemInfo[i]
    ti1   = info.ti1
    ti2   = info.ti2

    info.weight  = nil
    info.x1      = x1 + dx * ti1
    info.y1      = y1 + dy * ti1
    info.x2      = x1 + dx * ti2
    info.y2      = y1 + dy * ti2
  end
  return itemInfo, len
end


--- Main methods

function World:add(item, x,y,w,h)
  local rect = self.rects[item]
  if rect then
    error('Item ' .. tostring(item) .. ' added to the world twice.')
  end
  assertIsRect(x,y,w,h)

  self.rects[item] = {x=x,y=y,w=w,h=h}

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  for cy = ct, ct+ch-1 do
    for cx = cl, cl+cw-1 do
      addItemToCell(self, item, cx, cy)
    end
  end

  return item
end

function World:remove(item)
  local x,y,w,h = self:getRect(item)

  self.rects[item] = nil
  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  for cy = ct, ct+ch-1 do
    for cx = cl, cl+cw-1 do
      removeItemFromCell(self, item, cx, cy)
    end
  end
end

function World:update(item, x2,y2,w2,h2)
  local x1,y1,w1,h1 = self:getRect(item)
  w2,h2 = w2 or w1, h2 or h1
  assertIsRect(x2,y2,w2,h2)

  if x1 ~= x2 or y1 ~= y2 or w1 ~= w2 or h1 ~= h2 then

    local cellSize = self.cellSize
    local cl1,ct1,cw1,ch1 = grid_toCellRect(cellSize, x1,y1,w1,h1)
    local cl2,ct2,cw2,ch2 = grid_toCellRect(cellSize, x2,y2,w2,h2)

    if cl1 ~= cl2 or ct1 ~= ct2 or cw1 ~= cw2 or ch1 ~= ch2 then

      local cr1, cb1 = cl1+cw1-1, ct1+ch1-1
      local cr2, cb2 = cl2+cw2-1, ct2+ch2-1
      local cyOut

      for cy = ct1, cb1 do
        cyOut = cy < ct2 or cy > cb2
        for cx = cl1, cr1 do
          if cyOut or cx < cl2 or cx > cr2 then
            removeItemFromCell(self, item, cx, cy)
          end
        end
      end

      for cy = ct2, cb2 do
        cyOut = cy < ct1 or cy > cb1
        for cx = cl2, cr2 do
          if cyOut or cx < cl1 or cx > cr1 then
            addItemToCell(self, item, cx, cy)
          end
        end
      end

    end

    local rect = self.rects[item]
    rect.x, rect.y, rect.w, rect.h = x2,y2,w2,h2

  end
end

function World:move(item, goalX, goalY, filter)
  local actualX, actualY, cols, len = self:check(item, goalX, goalY, filter)

  self:update(item, actualX, actualY)

  return actualX, actualY, cols, len
end

function World:check(item, goalX, goalY, filter)
  filter = filter or defaultFilter

  local visited = {[item] = true}
  local visitedFilter = function(itm, other)
    if visited[other] then return false end
    return filter(itm, other)
  end

  local cols, len = {}, 0

  local x,y,w,h = self:getRect(item)

  local projected_cols, projected_len = self:project(item, x,y,w,h, goalX,goalY, visitedFilter)

  while projected_len > 0 do
    local col = projected_cols[1]
    len       = len + 1
    cols[len] = col

    visited[col.other] = true

    local response = getResponseByName(self, col.type)

    goalX, goalY, projected_cols, projected_len = response(
      self,
      col,
      x, y, w, h,
      goalX, goalY,
      visitedFilter
    )
  end

  return goalX, goalY, cols, len
end


-- Public library functions

bump.newWorld = function(cellSize)
  cellSize = cellSize or 64
  assertIsPositiveNumber(cellSize, 'cellSize')
  local world = setmetatable({
    cellSize       = cellSize,
    rects          = {},
    rows           = {},
    nonEmptyCells  = {},
    responses = {}
  }, World_mt)

  world:addResponse('touch', touch)
  world:addResponse('cross', cross)
  world:addResponse('slide', slide)
  world:addResponse('bounce', bounce)

  return world
end

bump.rect = {
  getNearestCorner              = rect_getNearestCorner,
  getSegmentIntersectionIndices = rect_getSegmentIntersectionIndices,
  getDiff                       = rect_getDiff,
  containsPoint                 = rect_containsPoint,
  isIntersecting                = rect_isIntersecting,
  getSquareDistance             = rect_getSquareDistance,
  detectCollision               = rect_detectCollision
}

bump.responses = {
  touch  = touch,
  cross  = cross,
  slide  = slide,
  bounce = bounce
}

return bump
function string.explode(str, div)
	assert(type(str) == "string" and type(div) == "string", "invalid arguments")
	local o = {}
	while true do
		local pos1,pos2 = str:find(div)
		if not pos1 then
			o[#o+1] = str
			break
		end
		o[#o+1],str = str:sub(1,pos1-1),str:sub(pos2+1)
	end
	return o
end

function math.round(num, idp)
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end

-- Averages an arbitrary number of angles (in radians).
function math.averageAngles(...)
	local x,y = 0,0
	for i=1,select('#',...) do local a= select(i,...) x, y = x+math.cos(a), y+math.sin(a) end
	return math.atan2(y, x)
end

-- Returns the distance between two points.
function math.dist(x1,y1, x2,y2) return ((x2-x1)^2+(y2-y1)^2)^0.5 end

-- Returns the angle between two points.
function math.angle(x1,y1, x2,y2) return math.atan2(x2-x1, y2-y1) end

-- Returns the closest multiple of 'size' (defaulting to 10).
function math.multiple(n, size) size = size or 10 return math.round(n/size)*size end

-- Clamps a number to within a certain range.
function math.clamp(n, low, high) return math.min(math.max(low, n), high) end

-- Linear interpolation between two numbers.
function lerp(a,b,t) return a+(b-a)*t end

-- Cosine interpolation between two numbers.
function cerp(a,b,t) local f=(1-math.cos(t*math.pi))*.5 return a*(1-f)+b*f end

-- Normalize two numbers.
function math.normalize(x,y) local l=(x*x+y*y)^.5 if l==0 then return 0,0,0 else return x/l,y/l,l end end

-- Returns 'n' rounded to the nearest 'deci'th (defaulting whole numbers).
function math.round(n, deci) deci = 10^(deci or 0) return math.floor(n*deci+.5)/deci end

-- Randomly returns either -1 or 1.
function math.rsign() return math.random(2) == 2 and 1 or -1 end

-- Returns 1 if number is positive, -1 if it's negative, or 0 if it's 0.
function math.sign(n) return n>0 and 1 or n<0 and -1 or 0 end

-- Checks if two lines intersect (or line segments if seg is true)
-- Lines are given as four numbers (two coordinates)
function findIntersect(l1p1x,l1p1y, l1p2x,l1p2y, l2p1x,l2p1y, l2p2x,l2p2y, seg1, seg2)
	local a1,b1,a2,b2 = l1p2y-l1p1y, l1p1x-l1p2x, l2p2y-l2p1y, l2p1x-l2p2x
	local c1,c2 = a1*l1p1x+b1*l1p1y, a2*l2p1x+b2*l2p1y
	local det,x,y = a1*b2 - a2*b1
	if det==0 then return false, "The lines are parallel." end
	x,y = (b2*c1-b1*c2)/det, (a1*c2-a2*c1)/det
	if seg1 or seg2 then
		local min,max = math.min, math.max
		if seg1 and not (min(l1p1x,l1p2x) <= x and x <= max(l1p1x,l1p2x) and min(l1p1y,l1p2y) <= y and y <= max(l1p1y,l1p2y)) or
			seg2 and not (min(l2p1x,l2p2x) <= x and x <= max(l2p1x,l2p2x) and min(l2p1y,l2p2y) <= y and y <= max(l2p1y,l2p2y)) then
			return false, "The lines don't intersect."
		end
	end
	return x,y
endlocal inspect ={
  _VERSION = 'inspect.lua 3.1.0',
  _URL     = 'http://github.com/kikito/inspect.lua',
  _DESCRIPTION = 'human-readable representations of tables',
  _LICENSE = [[
    MIT LICENSE

    Copyright (c) 2013 Enrique Garc√≠a Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

local tostring = tostring

inspect.KEY       = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})
inspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})

-- Apostrophizes the string if it has quotes, but not aphostrophes
-- Otherwise, it returns a regular quoted string
local function smartQuote(str)
  if str:match('"') and not str:match("'") then
    return "'" .. str .. "'"
  end
  return '"' .. str:gsub('"', '\\"') .. '"'
end

-- \a => '\\a', \0 => '\\0', 31 => '\31'
local shortControlCharEscapes = {
  ["\a"] = "\\a",  ["\b"] = "\\b", ["\f"] = "\\f", ["\n"] = "\\n",
  ["\r"] = "\\r",  ["\t"] = "\\t", ["\v"] = "\\v"
}
local longControlCharEscapes = {} -- \a => nil, \0 => \000, 31 => \031
for i=0, 31 do
  local ch = string.char(i)
  if not shortControlCharEscapes[ch] then
    shortControlCharEscapes[ch] = "\\"..i
    longControlCharEscapes[ch]  = string.format("\\%03d", i)
  end
end

local function escape(str)
  return (str:gsub("\\", "\\\\")
             :gsub("(%c)%f[0-9]", longControlCharEscapes)
             :gsub("%c", shortControlCharEscapes))
end

local function isIdentifier(str)
  return type(str) == 'string' and str:match( "^[_%a][_%a%d]*$" )
end

local function isSequenceKey(k, sequenceLength)
  return type(k) == 'number'
     and 1 <= k
     and k <= sequenceLength
     and math.floor(k) == k
end

local defaultTypeOrders = {
  ['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,
  ['function'] = 5, ['userdata'] = 6, ['thread'] = 7
}

local function sortKeys(a, b)
  local ta, tb = type(a), type(b)

  -- strings and numbers are sorted numerically/alphabetically
  if ta == tb and (ta == 'string' or ta == 'number') then return a < b end

  local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]
  -- Two default types are compared according to the defaultTypeOrders table
  if dta and dtb then return defaultTypeOrders[ta] < defaultTypeOrders[tb]
  elseif dta     then return true  -- default types before custom ones
  elseif dtb     then return false -- custom types after default ones
  end

  -- custom types are sorted out alphabetically
  return ta < tb
end

-- For implementation reasons, the behavior of rawlen & # is "undefined" when
-- tables aren't pure sequences. So we implement our own # operator.
local function getSequenceLength(t)
  local len = 1
  local v = rawget(t,len)
  while v ~= nil do
    len = len + 1
    v = rawget(t,len)
  end
  return len - 1
end

local function getNonSequentialKeys(t)
  local keys = {}
  local sequenceLength = getSequenceLength(t)
  for k,_ in pairs(t) do
    if not isSequenceKey(k, sequenceLength) then table.insert(keys, k) end
  end
  table.sort(keys, sortKeys)
  return keys, sequenceLength
end

local function getToStringResultSafely(t, mt)
  local __tostring = type(mt) == 'table' and rawget(mt, '__tostring')
  local str, ok
  if type(__tostring) == 'function' then
    ok, str = pcall(__tostring, t)
    str = ok and str or 'error: ' .. tostring(str)
  end
  if type(str) == 'string' and #str > 0 then return str end
end

local function countTableAppearances(t, tableAppearances)
  tableAppearances = tableAppearances or {}

  if type(t) == 'table' then
    if not tableAppearances[t] then
      tableAppearances[t] = 1
      for k,v in pairs(t) do
        countTableAppearances(k, tableAppearances)
        countTableAppearances(v, tableAppearances)
      end
      countTableAppearances(getmetatable(t), tableAppearances)
    else
      tableAppearances[t] = tableAppearances[t] + 1
    end
  end

  return tableAppearances
end

local copySequence = function(s)
  local copy, len = {}, #s
  for i=1, len do copy[i] = s[i] end
  return copy, len
end

local function makePath(path, ...)
  local keys = {...}
  local newPath, len = copySequence(path)
  for i=1, #keys do
    newPath[len + i] = keys[i]
  end
  return newPath
end

local function processRecursive(process, item, path, visited)

    if item == nil then return nil end
    if visited[item] then return visited[item] end

    local processed = process(item, path)
    if type(processed) == 'table' then
      local processedCopy = {}
      visited[item] = processedCopy
      local processedKey

      for k,v in pairs(processed) do
        processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)
        if processedKey ~= nil then
          processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)
        end
      end

      local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)
      setmetatable(processedCopy, mt)
      processed = processedCopy
    end
    return processed
end



-------------------------------------------------------------------

local Inspector = {}
local Inspector_mt = {__index = Inspector}

function Inspector:puts(...)
  local args   = {...}
  local buffer = self.buffer
  local len    = #buffer
  for i=1, #args do
    len = len + 1
    buffer[len] = args[i]
  end
end

function Inspector:down(f)
  self.level = self.level + 1
  f()
  self.level = self.level - 1
end

function Inspector:tabify()
  self:puts(self.newline, string.rep(self.indent, self.level))
end

function Inspector:alreadyVisited(v)
  return self.ids[v] ~= nil
end

function Inspector:getId(v)
  local id = self.ids[v]
  if not id then
    local tv = type(v)
    id              = (self.maxIds[tv] or 0) + 1
    self.maxIds[tv] = id
    self.ids[v]     = id
  end
  return tostring(id)
end

function Inspector:putKey(k)
  if isIdentifier(k) then return self:puts(k) end
  self:puts("[")
  self:putValue(k)
  self:puts("]")
end

function Inspector:putTable(t)
  if t == inspect.KEY or t == inspect.METATABLE then
    self:puts(tostring(t))
  elseif self:alreadyVisited(t) then
    self:puts('<table ', self:getId(t), '>')
  elseif self.level >= self.depth then
    self:puts('{...}')
  else
    if self.tableAppearances[t] > 1 then self:puts('<', self:getId(t), '>') end

    local nonSequentialKeys, sequenceLength = getNonSequentialKeys(t)
    local mt                = getmetatable(t)
    local toStringResult    = getToStringResultSafely(t, mt)

    self:puts('{')
    self:down(function()
      if toStringResult then
        self:puts(' -- ', escape(toStringResult))
        if sequenceLength >= 1 then self:tabify() end
      end

      local count = 0
      for i=1, sequenceLength do
        if count > 0 then self:puts(',') end
        self:puts(' ')
        self:putValue(t[i])
        count = count + 1
      end

      for _,k in ipairs(nonSequentialKeys) do
        if count > 0 then self:puts(',') end
        self:tabify()
        self:putKey(k)
        self:puts(' = ')
        self:putValue(t[k])
        count = count + 1
      end

      if mt then
        if count > 0 then self:puts(',') end
        self:tabify()
        self:puts('<metatable> = ')
        self:putValue(mt)
      end
    end)

    if #nonSequentialKeys > 0 or mt then -- result is multi-lined. Justify closing }
      self:tabify()
    elseif sequenceLength > 0 then -- array tables have one extra space before closing }
      self:puts(' ')
    end

    self:puts('}')
  end
end

function Inspector:putValue(v)
  local tv = type(v)

  if tv == 'string' then
    self:puts(smartQuote(escape(v)))
  elseif tv == 'number' or tv == 'boolean' or tv == 'nil' then
    self:puts(tostring(v))
  elseif tv == 'table' then
    self:putTable(v)
  else
    self:puts('<',tv,' ',self:getId(v),'>')
  end
end

-------------------------------------------------------------------

function inspect.inspect(root, options)
  options       = options or {}

  local depth   = options.depth   or math.huge
  local newline = options.newline or '\n'
  local indent  = options.indent  or '  '
  local process = options.process

  if process then
    root = processRecursive(process, root, {}, {})
  end

  local inspector = setmetatable({
    depth            = depth,
    level            = 0,
    buffer           = {},
    ids              = {},
    maxIds           = {},
    newline          = newline,
    indent           = indent,
    tableAppearances = countTableAppearances(root)
  }, Inspector_mt)

  inspector:putValue(root)

  return table.concat(inspector.buffer)
end

setmetatable(inspect, { __call = function(_, ...) return inspect.inspect(...) end })

return inspect

--[[
Copyright (c) 2010-2015 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local _PATH = (...):match('^(.*[%./])[^%.%/]+$') or ''
local cos, sin = math.cos, math.sin

local camera = {}
camera.__index = camera

-- Movement interpolators (for camera locking/windowing)
camera.smooth = {}

function camera.smooth.none()
	return function(dx,dy) return dx,dy end
end

function camera.smooth.linear(speed)
	assert(type(speed) == "number", "Invalid parameter: speed = "..tostring(speed))
	return function(dx,dy, s)
		-- normalize direction
		local d = math.sqrt(dx*dx+dy*dy)
		local dts = math.min((s or speed) * love.timer.getDelta(), d) -- prevent overshooting the goal
		if d > 0 then
			dx,dy = dx/d, dy/d
		end

		return dx*dts, dy*dts
	end
end

function camera.smooth.damped(stiffness)
	assert(type(stiffness) == "number", "Invalid parameter: stiffness = "..tostring(stiffness))
	return function(dx,dy, s)
		local dts = love.timer.getDelta() * (s or stiffness)
		return dx*dts, dy*dts
	end
end


local function new(x,y, zoom, rot, smoother)
	x,y  = x or love.graphics.getWidth()/2, y or love.graphics.getHeight()/2
	zoom = zoom or 1
	rot  = rot or 0
	smoother = smoother or camera.smooth.none() -- for locking, see below
	return setmetatable({x = x, y = y, scale = zoom, rot = rot, smoother = smoother}, camera)
end

function camera:lookAt(x,y)
	self.x, self.y = x, y
	return self
end

function camera:move(dx,dy)
	self.x, self.y = self.x + dx, self.y + dy
	return self
end

function camera:position()
	return self.x, self.y
end

function camera:rotate(phi)
	self.rot = self.rot + phi
	return self
end

function camera:rotateTo(phi)
	self.rot = phi
	return self
end

function camera:zoom(mul)
	self.scale = self.scale * mul
	return self
end

function camera:zoomTo(zoom)
	self.scale = zoom
	return self
end

function camera:attach(x,y,w,h, noclip)
	x,y = x or 0, y or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	self._sx,self._sy,self._sw,self._sh = love.graphics.getScissor()
	if not noclip then
		love.graphics.setScissor(x,y,w,h)
	end

	local cx,cy = x+w/2, y+h/2
	love.graphics.push()
	love.graphics.translate(cx, cy)
	love.graphics.scale(self.scale)
	love.graphics.rotate(self.rot)
	love.graphics.translate(-self.x, -self.y)
end

function camera:detach()
	love.graphics.pop()
	love.graphics.setScissor(self._sx,self._sy,self._sw,self._sh)
end

function camera:draw(...)
	local x,y,w,h,noclip,func
	local nargs = select("#", ...)
	if nargs == 1 then
		func = ...
	elseif nargs == 5 then
		x,y,w,h,func = ...
	elseif nargs == 6 then
		x,y,w,h,noclip,func = ...
	else
		error("Invalid arguments to camera:draw()")
	end

	self:attach(x,y,w,h,noclip)
	func()
	self:detach()
end

-- world coordinates to camera coordinates
function camera:cameraCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = ((x,y) - (self.x, self.y)):rotated(self.rot) * self.scale + center
	local c,s = cos(self.rot), sin(self.rot)
	x,y = x - self.x, y - self.y
	x,y = c*x - s*y, s*x + c*y
	return x*self.scale + w/2 + ox, y*self.scale + h/2 + oy
end

-- camera coordinates to world coordinates
function camera:worldCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = (((x,y) - center) / self.scale):rotated(-self.rot) + (self.x,self.y)
	local c,s = cos(-self.rot), sin(-self.rot)
	x,y = (x - w/2 - ox) / self.scale, (y - h/2 - oy) / self.scale
	x,y = c*x - s*y, s*x + c*y
	return x+self.x, y+self.y
end

function camera:mousePosition(ox,oy,w,h)
	local mx,my = love.mouse.getPosition()
	return self:worldCoords(mx,my, ox,oy,w,h)
end

-- camera scrolling utilities
function camera:lockX(x, smoother, ...)
	local dx, dy = (smoother or self.smoother)(x - self.x, self.y, ...)
	self.x = self.x + dx
	return self
end

function camera:lockY(y, smoother, ...)
	local dx, dy = (smoother or self.smoother)(self.x, y - self.y, ...)
	self.y = self.y + dy
	return self
end

function camera:lockPosition(x,y, smoother, ...)
	return self:move((smoother or self.smoother)(x - self.x, y - self.y, ...))
end

function camera:lockWindow(x, y, x_min, x_max, y_min, y_max, smoother, ...)
	-- figure out displacement in camera coordinates
	x,y = self:cameraCoords(x,y)
	local dx, dy = 0,0
	if x < x_min then
		dx = x - x_min
	elseif x > x_max then
		dx = x - x_max
	end
	if y < y_min then
		dy = y - y_min
	elseif y > y_max then
		dy = y - y_max
	end

	-- transform displacement to movement in world coordinates
	local c,s = cos(-self.rot), sin(-self.rot)
	dx,dy = (c*dx - s*dy) / self.scale, (s*dx + c*dy) / self.scale

	-- move
	self:move((smoother or self.smoother)(dx,dy,...))
end

-- the module
return setmetatable({new = new, smooth = camera.smooth},
	{__call = function(_, ...) return new(...) end})
--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local function include_helper(to, from, seen)
	if from == nil then
		return to
	elseif type(from) ~= 'table' then
		return from
	elseif seen[from] then
		return seen[from]
	end

	seen[from] = to
	for k,v in pairs(from) do
		k = include_helper({}, k, seen) -- keys might also be tables
		if to[k] == nil then
			to[k] = include_helper({}, v, seen)
		end
	end
	return to
end

-- deeply copies `other' into `class'. keys in `other' that are already
-- defined in `class' are omitted
local function include(class, other)
	return include_helper(class, other, {})
end

-- returns a deep copy of `other'
local function clone(other)
	return setmetatable(include({}, other), getmetatable(other))
end

local function new(class)
	-- mixins
	class = class or {}  -- class can be nil
	local inc = class.__includes or {}
	if getmetatable(inc) then inc = {inc} end

	for _, other in ipairs(inc) do
		if type(other) == "string" then
			other = _G[other]
		end
		include(class, other)
	end

	-- class implementation
	class.__index = class
	class.init    = class.init    or class[1] or function() end
	class.include = class.include or include
	class.clone   = class.clone   or clone

	-- constructor call
	return setmetatable(class, {__call = function(c, ...)
		local o = setmetatable({}, c)
		o:init(...)
		return o
	end})
end

-- interface for cross class-system compatibility (see https://github.com/bartbes/Class-Commons).
if class_commons ~= false and not common then
	common = {}
	function common.class(name, prototype, parent)
		return new{__includes = {prototype, parent}}
	end
	function common.instance(class, ...)
		return class(...)
	end
end


-- the module
return setmetatable({new = new, include = include, clone = clone},
	{__call = function(_,...) return new(...) end})
--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local function __NULL__() end

 -- default gamestate produces error on every callback
local state_init = setmetatable({leave = __NULL__},
		{__index = function() error("Gamestate not initialized. Use Gamestate.switch()") end})
local stack = {state_init}
local initialized_states = setmetatable({}, {__mode = "k"})
local state_is_dirty = true

local GS = {}
function GS.new(t) return t or {} end -- constructor - deprecated!

local function change_state(stack_offset, to, ...)
	local pre = stack[#stack]

	-- initialize only on first call
	;(initialized_states[to] or to.init or __NULL__)(to)
	initialized_states[to] = __NULL__

	stack[#stack+stack_offset] = to
	state_is_dirty = true
	return (to.enter or __NULL__)(to, pre, ...)
end

function GS.switch(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call switch with colon operator")
	;(stack[#stack].leave or __NULL__)(stack[#stack])
	return change_state(0, to, ...)
end

function GS.push(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call push with colon operator")
	return change_state(1, to, ...)
end

function GS.pop(...)
	assert(#stack > 1, "No more states to pop!")
	local pre, to = stack[#stack], stack[#stack-1]
	stack[#stack] = nil
	;(pre.leave or __NULL__)(pre)
	state_is_dirty = true
	return (to.resume or __NULL__)(to, pre, ...)
end

function GS.current()
	return stack[#stack]
end

-- fetch event callbacks from love.handlers
local all_callbacks = { 'draw', 'errhand', 'update' }
for k in pairs(love.handlers) do
	all_callbacks[#all_callbacks+1] = k
end

function GS.registerEvents(callbacks)
	local registry = {}
	callbacks = callbacks or all_callbacks
	for _, f in ipairs(callbacks) do
		registry[f] = love[f] or __NULL__
		love[f] = function(...)
			registry[f](...)
			return GS[f](...)
		end
	end
end

-- forward any undefined functions
setmetatable(GS, {__index = function(_, func)
	-- call function only if at least one 'update' was called beforehand
	-- (see issue #46)
	if not state_is_dirty or func == 'update' then
		state_is_dirty = false
		return function(...)
			return (stack[#stack][func] or __NULL__)(stack[#stack], ...)
		end
	end
	return __NULL__
end})

return GS
--[[
Copyright (c) 2012-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local Registry = {}
Registry.__index = function(self, key)
	return Registry[key] or (function()
		local t = {}
		rawset(self, key, t)
		return t
	end)()
end

function Registry:register(s, f)
	self[s][f] = f
	return f
end

function Registry:emit(s, ...)
	for f in pairs(self[s]) do
		f(...)
	end
end

function Registry:remove(s, ...)
	local f = {...}
	for i = 1,select('#', ...) do
		self[s][f[i]] = nil
	end
end

function Registry:clear(...)
	local s = {...}
	for i = 1,select('#', ...) do
		self[s[i]] = {}
	end
end

function Registry:emitPattern(p, ...)
	for s in pairs(self) do
		if s:match(p) then self:emit(s, ...) end
	end
end

function Registry:registerPattern(p, f)
	for s in pairs(self) do
		if s:match(p) then self:register(s, f) end
	end
	return f
end

function Registry:removePattern(p, ...)
	for s in pairs(self) do
		if s:match(p) then self:remove(s, ...) end
	end
end

function Registry:clearPattern(p)
	for s in pairs(self) do
		if s:match(p) then self[s] = {} end
	end
end

-- instancing
function Registry.new()
	return setmetatable({}, Registry)
end

-- default instance
local default = Registry.new()

-- module forwards calls to default instance
local module = {}
for k in pairs(Registry) do
	if k ~= "__index" then
		module[k] = function(...) return default[k](default, ...) end
	end
end

return setmetatable(module, {__call = Registry.new})
--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local Timer = {}
Timer.__index = Timer

local function _nothing_() end

function Timer:update(dt)
	local to_remove = {}

	for handle in pairs(self.functions) do
		-- handle: {
		--   time = <number>,
		--   after = <function>,
		--   during = <function>,
		--   limit = <number>,
		--   count = <number>,
		-- }

		handle.time = handle.time + dt
		handle.during(dt, math.max(handle.limit - handle.time, 0))

		while handle.time >= handle.limit and handle.count > 0 do
			if handle.after(handle.after) == false then
				handle.count = 0
				break
			end
			handle.time = handle.time - handle.limit
			handle.count = handle.count - 1
		end

		if handle.count == 0 then
			table.insert(to_remove, handle)
		end
	end

	for i = 1, #to_remove do
		self.functions[to_remove[i]] = nil
	end
end

function Timer:during(delay, during, after)
	local handle = { time = 0, during = during, after = after or _nothing_, limit = delay, count = 1 }
	self.functions[handle] = true
	return handle
end

function Timer:after(delay, func)
	return self:during(delay, _nothing_, func)
end

function Timer:every(delay, after, count)
	local count = count or math.huge -- exploit below: math.huge - 1 = math.huge
	local handle = { time = 0, during = _nothing_, after = after, limit = delay, count = count }
	self.functions[handle] = true
	return handle
end

function Timer:cancel(handle)
	self.functions[handle] = nil
end

function Timer:clear()
	self.functions = {}
end

function Timer:script(f)
	local co = coroutine.wrap(f)
	co(function(t)
		self:after(t, co)
		coroutine.yield()
	end)
end

Timer.tween = setmetatable({
	-- helper functions
	out = function(f) -- 'rotates' a function
		return function(s, ...) return 1 - f(1-s, ...) end
	end,
	chain = function(f1, f2) -- concatenates two functions
		return function(s, ...) return (s < .5 and f1(2*s, ...) or 1 + f2(2*s-1, ...)) * .5 end
	end,

	-- useful tweening functions
	linear = function(s) return s end,
	quad   = function(s) return s*s end,
	cubic  = function(s) return s*s*s end,
	quart  = function(s) return s*s*s*s end,
	quint  = function(s) return s*s*s*s*s end,
	sine   = function(s) return 1-math.cos(s*math.pi/2) end,
	expo   = function(s) return 2^(10*(s-1)) end,
	circ   = function(s) return 1 - math.sqrt(1-s*s) end,

	back = function(s,bounciness)
		bounciness = bounciness or 1.70158
		return s*s*((bounciness+1)*s - bounciness)
	end,

	bounce = function(s) -- magic numbers ahead
		local a,b = 7.5625, 1/2.75
		return math.min(a*s^2, a*(s-1.5*b)^2 + .75, a*(s-2.25*b)^2 + .9375, a*(s-2.625*b)^2 + .984375)
	end,

	elastic = function(s, amp, period)
		amp, period = amp and math.max(1, amp) or 1, period or .3
		return (-amp * math.sin(2*math.pi/period * (s-1) - math.asin(1/amp))) * 2^(10*(s-1))
	end,
}, {

-- register new tween
__call = function(tween, self, len, subject, target, method, after, ...)
	-- recursively collects fields that are defined in both subject and target into a flat list
	local function tween_collect_payload(subject, target, out)
		for k,v in pairs(target) do
			local ref = subject[k]
			assert(type(v) == type(ref), 'Type mismatch in field "'..k..'".')
			if type(v) == 'table' then
				tween_collect_payload(ref, v, out)
			else
				local ok, delta = pcall(function() return (v-ref)*1 end)
				assert(ok, 'Field "'..k..'" does not support arithmetic operations')
				out[#out+1] = {subject, k, delta}
			end
		end
		return out
	end

	method = tween[method or 'linear'] -- see __index
	local payload, t, args = tween_collect_payload(subject, target, {}), 0, {...}

	local last_s = 0
	return self:during(len, function(dt)
		t = t + dt
		local s = method(math.min(1, t/len), unpack(args))
		local ds = s - last_s
		last_s = s
		for _, info in ipairs(payload) do
			local ref, key, delta = unpack(info)
			ref[key] = ref[key] + delta * ds
		end
	end, after)
end,

-- fetches function and generated compositions for method `key`
__index = function(tweens, key)
	if type(key) == 'function' then return key end

	assert(type(key) == 'string', 'Method must be function or string.')
	if rawget(tweens, key) then return rawget(tweens, key) end

	local function construct(pattern, f)
		local method = rawget(tweens, key:match(pattern))
		if method then return f(method) end
		return nil
	end

	local out, chain = rawget(tweens,'out'), rawget(tweens,'chain')
	return construct('^in%-([^-]+)$', function(...) return ... end)
	       or construct('^out%-([^-]+)$', out)
	       or construct('^in%-out%-([^-]+)$', function(f) return chain(f, out(f)) end)
	       or construct('^out%-in%-([^-]+)$', function(f) return chain(out(f), f) end)
	       or error('Unknown interpolation method: ' .. key)
end})

-- Timer instancing
function Timer.new()
	return setmetatable({functions = {}, tween = Timer.tween}, Timer)
end

-- default instance
local default = Timer.new()

-- module forwards calls to default instance
local module = {}
for k in pairs(Timer) do
	if k ~= "__index" then
		module[k] = function(...) return default[k](default, ...) end
	end
end
module.tween = setmetatable({}, {
	__index = Timer.tween,
	__newindex = function(k,v) Timer.tween[k] = v end,
	__call = function(t, ...) return default:tween(...) end,
})

return setmetatable(module, {__call = Timer.new})
--[[
Copyright (c) 2012-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local sqrt, cos, sin, atan2 = math.sqrt, math.cos, math.sin, math.atan2

local function str(x,y)
	return "("..tonumber(x)..","..tonumber(y)..")"
end

local function mul(s, x,y)
	return s*x, s*y
end

local function div(s, x,y)
	return x/s, y/s
end

local function add(x1,y1, x2,y2)
	return x1+x2, y1+y2
end

local function sub(x1,y1, x2,y2)
	return x1-x2, y1-y2
end

local function permul(x1,y1, x2,y2)
	return x1*x2, y1*y2
end

local function dot(x1,y1, x2,y2)
	return x1*x2 + y1*y2
end

local function det(x1,y1, x2,y2)
	return x1*y2 - y1*x2
end

local function eq(x1,y1, x2,y2)
	return x1 == x2 and y1 == y2
end

local function lt(x1,y1, x2,y2)
	return x1 < x2 or (x1 == x2 and y1 < y2)
end

local function le(x1,y1, x2,y2)
	return x1 <= x2 and y1 <= y2
end

local function len2(x,y)
	return x*x + y*y
end

local function len(x,y)
	return sqrt(x*x + y*y)
end

local function fromPolar(angle, radius)
	return cos(angle)*radius, sin(angle)*radius
end

local function toPolar(x, y)
	return atan2(y,x), len(x,y)
end

local function dist2(x1,y1, x2,y2)
	return len2(x1-x2, y1-y2)
end

local function dist(x1,y1, x2,y2)
	return len(x1-x2, y1-y2)
end

local function normalize(x,y)
	local l = len(x,y)
	if l > 0 then
		return x/l, y/l
	end
	return x,y
end

local function rotate(phi, x,y)
	local c, s = cos(phi), sin(phi)
	return c*x - s*y, s*x + c*y
end

local function perpendicular(x,y)
	return -y, x
end

local function project(x,y, u,v)
	local s = (x*u + y*v) / (u*u + v*v)
	return s*u, s*v
end

local function mirror(x,y, u,v)
	local s = 2 * (x*u + y*v) / (u*u + v*v)
	return s*u - x, s*v - y
end

-- ref.: http://blog.signalsondisplay.com/?p=336
local function trim(maxLen, x, y)
	local s = maxLen * maxLen / len2(x, y)
	s = s > 1 and 1 or math.sqrt(s)
	return x * s, y * s
end

local function angleTo(x,y, u,v)
	if u and v then
		return atan2(y, x) - atan2(v, u)
	end
	return atan2(y, x)
end

-- the module
return {
	str = str,

	fromPolar = fromPolar,
	toPolar = toPolar,

	-- arithmetic
	mul    = mul,
	div    = div,
	add    = add,
	sub    = sub,
	permul = permul,
	dot    = dot,
	det    = det,
	cross  = det,

	-- relation
	eq = eq,
	lt = lt,
	le = le,

	-- misc operations
	len2          = len2,
	len           = len,
	dist2         = dist2,
	dist          = dist,
	normalize     = normalize,
	rotate        = rotate,
	perpendicular = perpendicular,
	project       = project,
	mirror        = mirror,
	trim          = trim,
	angleTo       = angleTo,
}
--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local assert = assert
local sqrt, cos, sin, atan2 = math.sqrt, math.cos, math.sin, math.atan2

local vector = {}
vector.__index = vector

local function new(x,y)
	return setmetatable({x = x or 0, y = y or 0}, vector)
end
local zero = new(0,0)

local function fromPolar(angle, radius)
	return new(cos(angle) * radius, sin(angle) * radius)
end

local function isvector(v)
	return type(v) == 'table' and type(v.x) == 'number' and type(v.y) == 'number'
end

function vector:clone()
	return new(self.x, self.y)
end

function vector:unpack()
	return self.x, self.y
end

function vector:__tostring()
	return "("..tonumber(self.x)..","..tonumber(self.y)..")"
end

function vector.__unm(a)
	return new(-a.x, -a.y)
end

function vector.__add(a,b)
	assert(isvector(a) and isvector(b), "Add: wrong argument types (<vector> expected)")
	return new(a.x+b.x, a.y+b.y)
end

function vector.__sub(a,b)
	assert(isvector(a) and isvector(b), "Sub: wrong argument types (<vector> expected)")
	return new(a.x-b.x, a.y-b.y)
end

function vector.__mul(a,b)
	if type(a) == "number" then
		return new(a*b.x, a*b.y)
	elseif type(b) == "number" then
		return new(b*a.x, b*a.y)
	else
		assert(isvector(a) and isvector(b), "Mul: wrong argument types (<vector> or <number> expected)")
		return a.x*b.x + a.y*b.y
	end
end

function vector.__div(a,b)
	assert(isvector(a) and type(b) == "number", "wrong argument types (expected <vector> / <number>)")
	return new(a.x / b, a.y / b)
end

function vector.__eq(a,b)
	return a.x == b.x and a.y == b.y
end

function vector.__lt(a,b)
	return a.x < b.x or (a.x == b.x and a.y < b.y)
end

function vector.__le(a,b)
	return a.x <= b.x and a.y <= b.y
end

function vector.permul(a,b)
	assert(isvector(a) and isvector(b), "permul: wrong argument types (<vector> expected)")
	return new(a.x*b.x, a.y*b.y)
end

function vector:toPolar()
	return new(atan2(self.x, self.y), self:len())
end

function vector:len2()
	return self.x * self.x + self.y * self.y
end

function vector:len()
	return sqrt(self.x * self.x + self.y * self.y)
end

function vector.dist(a, b)
	assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
	local dx = a.x - b.x
	local dy = a.y - b.y
	return sqrt(dx * dx + dy * dy)
end

function vector.dist2(a, b)
	assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
	local dx = a.x - b.x
	local dy = a.y - b.y
	return (dx * dx + dy * dy)
end

function vector:normalizeInplace()
	local l = self:len()
	if l > 0 then
		self.x, self.y = self.x / l, self.y / l
	end
	return self
end

function vector:normalized()
	return self:clone():normalizeInplace()
end

function vector:rotateInplace(phi)
	local c, s = cos(phi), sin(phi)
	self.x, self.y = c * self.x - s * self.y, s * self.x + c * self.y
	return self
end

function vector:rotated(phi)
	local c, s = cos(phi), sin(phi)
	return new(c * self.x - s * self.y, s * self.x + c * self.y)
end

function vector:perpendicular()
	return new(-self.y, self.x)
end

function vector:projectOn(v)
	assert(isvector(v), "invalid argument: cannot project vector on " .. type(v))
	-- (self * v) * v / v:len2()
	local s = (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
	return new(s * v.x, s * v.y)
end

function vector:mirrorOn(v)
	assert(isvector(v), "invalid argument: cannot mirror vector on " .. type(v))
	-- 2 * self:projectOn(v) - self
	local s = 2 * (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
	return new(s * v.x - self.x, s * v.y - self.y)
end

function vector:cross(v)
	assert(isvector(v), "cross: wrong argument types (<vector> expected)")
	return self.x * v.y - self.y * v.x
end

-- ref.: http://blog.signalsondisplay.com/?p=336
function vector:trimInplace(maxLen)
	local s = maxLen * maxLen / self:len2()
	s = (s > 1 and 1) or math.sqrt(s)
	self.x, self.y = self.x * s, self.y * s
	return self
end

function vector:angleTo(other)
	if other then
		return atan2(self.y, self.x) - atan2(other.y, other.x)
	end
	return atan2(self.y, self.x)
end

function vector:trimmed(maxLen)
	return self:clone():trimInplace(maxLen)
end


-- the module
return setmetatable({new = new, fromPolar = fromPolar, isvector = isvector, zero = zero},
	{__call = function(_, ...) return new(...) end})
require "collisions";
require "player";
require "weapon/manager-weapon";
require "enemy/manager-enemy";
require "asset/config/game-timeline";
require "background";

State_Game = {};

function State_Game:init()
  BumpWorld = Bump.newWorld(32);
  self.player = Player();
  self.weaponManager = ManagerWeapon(self.player);
  self.enemyManager = ManagerEnemy(self.weaponManager);
  self.background = Background();

  self.timePassed = 0;
  self.timelineIndex = 1;
  self.lastTime = 0;
end

function State_Game:enter()

end

function State_Game:keypressed(key, scancode, isrepeat)
  if key == KEY_LEFT then
    self.player.leftPressed = true;
  end

  if key == KEY_RIGHT then
    self.player.rightPressed = true;
  end

  if key == KEY_UP then
    self.player.upPressed = true;
  end

  if key == KEY_DOWN then
    self.player.downPressed = true;
  end

  if key == KEY_RUN then
    self.player.runPressed = true;
  end

  if key == KEY_FIRE_STREAM then
    self.player:fireStream();
  end

  if key == KEY_FIRE_SPREAD then
    self.player:fireSpread();
  end
end

function State_Game:resume()
  self.player:resetKeys();
end

function State_Game:keyreleased(key, scancode)
  if key == KEY_LEFT then
    self.player.leftPressed = false;
  end

  if key == KEY_RIGHT then
    self.player.rightPressed = false;
  end

  if key == KEY_UP then
    self.player.upPressed = false;
  end

  if key == KEY_DOWN then
    self.player.downPressed = false;
  end

  if key == KEY_RUN then
    self.player.runPressed = false;
  end
end

function State_Game:update(dt)
  self:updateTimeline(dt);
  self.background:update(dt);
  self.enemyManager:update(dt);
  self.player:update(dt);
  self.weaponManager:update(dt);
end

function State_Game:updateTimeline(dt)
  self.timePassed = self.timePassed + dt;

  if(GAME_TIMELINE[self.timelineIndex]) then
    if(self.lastTime + self.timePassed > self.lastTime + GAME_TIMELINE[self.timelineIndex].time) then
      local enemies = GAME_TIMELINE[self.timelineIndex].enemies;

      for index, enemy in ipairs(enemies) do
        self.enemyManager:spawnEnemy(enemy);
      end

      self.lastTime = self.lastTime + GAME_TIMELINE[self.timelineIndex].time;
      self.timelineIndex = self.timelineIndex + 1;
      self.timePassed = 0;
    end
  end
end

function State_Game:draw()
  love.graphics.setColor(255, 255, 255);

  self.background:draw();
  self.enemyManager:draw();
  self.player:draw();
  self.weaponManager:draw();

  if DRAW_POSITIONS then
    love.graphics.setColor(255, 255, 255);
    love.graphics.print("Player: " .. self.player.box.x .. ", " .. self.player.box.y, 32, 32);
  end
endrequire "weapon/weapon-bullet";
require "weapon/weapon-bullet-pickup";

ManagerWeapon = Class {
  init = function(self, player)
    self.weapons = {};
    self.player = player;
  end
};

function ManagerWeapon:spawnBullet(bx, by, type)
  if type == "bullet" then
    table.insert(self.weapons, Bullet(bx, by));
  elseif type == "bullet-pickup" then
    table.insert(self.weapons, BulletPickup(bx, by));
  end
end

function ManagerWeapon:update(dt)
  local activeWeapons = {};

  for index, weapon in ipairs(self.weapons) do
    weapon:update(dt, self.player);

    if weapon.active then
      table.insert(activeWeapons, weapon);
    end
  end

  self.weapons = activeWeapons;
end

function ManagerWeapon:draw()
  for index, weapon in ipairs(self.weapons) do
    weapon:draw();
  end
endBulletPickup = Class {
  init = function(self, x, y)
    self.box = {
      x = x,
      y = y,
      w = BULLET_INITIAL_DIMENSIONS.w,
      h = BULLET_INITIAL_DIMENSIONS.h
    };

    BumpWorld:add(self, self.box.x, self.box.y, self.box.w, self.box.h);

    self.velocity = { x = 0, y = BULLET_SPEED };

    self.thrown = false;
    self.pickedUp = false;
    self.active = true;
    self.type = "bullet-pickup";
  end
};

function BulletPickup:pickUp()
  self.pickedUp = true;
end

function BulletPickup:update(dt, player)
  if not self.active then
    return;
  end

  if self.pickedUp then
    self:followPlayer(player);
  else
    self:updatePosition(dt);
  end
end

function BulletPickup:followPlayer(player)
  local dx = player.box.x + player.box.w / 2;
  local dy = player.box.y + player.box.h / 2;

  dx = dx - BULLET_SIZE;
  dy = dy - BULLET_SIZE - 20;

  BumpWorld:update(self, dx, dy);

  self.box.x = dx;
  self.box.y = dy;
end

function BulletPickup:updatePosition(dt)
  local dx = self.box.x + self.velocity.x * dt;
  local dy = self.box.y + self.velocity.y * dt;

  local actualX, actualY, cols, len = BumpWorld:move(self, dx, dy, bulletCollision);

  self.box.x = actualX;
  self.box.y = actualY;

  if self.box.x < 0 - BULLET_SIZE or self.box.x > SCREEN_WIDTH or self.box.y < 0 - BULLET_SIZE or self.box.y > SCREEN_HEIGHT then
    self.active = false;
  end
end

function BulletPickup:throwStraight()
  if not self.pickedUp then
    return;
  end

  self.pickedUp = false;
  self.thrown = true;

  self.velocity.x = 0;
  self.velocity.y = -BULLET_SPEED;
end

function BulletPickup:throwSpread(angle)
  if not self.pickedUp then
    return;
  end

  self.pickedUp = false;
  self.thrown = true;

  local v = Vector.fromPolar(angle, 1);
  self.velocity.x = v.x * BULLET_SPEED;
  self.velocity.y = v.y * BULLET_SPEED;
end

function BulletPickup:draw()
  if not self.active then
    return;
  end

  love.graphics.setColor(255, 255, 0);
  love.graphics.rectangle("fill", self.box.x, self.box.y, self.box.w, self.box.h);

  if DRAW_BOXES then
    love.graphics.setColor(255, 255, 255);
    love.graphics.rectangle("line", BumpWorld:getRect(self));
  end
endBullet = Class {
  init = function(self, x, y)
    self.box = {
      x = x,
      y = y,
      w = BULLET_INITIAL_DIMENSIONS.w,
      h = BULLET_INITIAL_DIMENSIONS.h
    };

    BumpWorld:add(self, self.box.x, self.box.y, self.box.w, self.box.h);

    self.velocity = { x = 0, y = BULLET_SPEED };

    self.active = true;
    self.type = "bullet";
  end
};

function Bullet:update(dt, player)
  if not self.active then
    return;
  end

  local dx = self.box.x + self.velocity.x * dt;
  local dy = self.box.y + self.velocity.y * dt;

  local actualX, actualY, cols, len = BumpWorld:move(self, dx, dy, bulletCollision);

  self.box.x = actualX;
  self.box.y = actualY;

  if self.box.x < 0 - BULLET_SIZE or self.box.x > SCREEN_WIDTH or self.box.y > SCREEN_HEIGHT then
    self.active = false;
  end
end

function Bullet:draw()
  if not self.active then
    return;
  end

  love.graphics.setColor(255, 0, 0);
  love.graphics.rectangle("fill", self.box.x, self.box.y, self.box.w, self.box.h);

  if DRAW_BOXES then
    love.graphics.setColor(255, 255, 255);
    love.graphics.rectangle("line", BumpWorld:getRect(self));
  end
end